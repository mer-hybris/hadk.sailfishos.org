{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sailfish OS Hardware Adaptation Development Kit","text":"<p>This is a guide to help you understand how you can port Sailfish OS to devices running Android\u2122 OS.</p> <p>Warning</p> <p>Modifying or replacing your device's software may void your device's warranty, lead to data loss, hair loss, financial loss, privacy loss, security breaches, or other damage, and therefore must be done entirely at your own risk. No one affiliated with this project is responsible for your actions but yourself. Good luck.</p>"},{"location":"android/","title":"Building the Android HAL","text":""},{"location":"android/#checking-out-source-of-the-android-base","title":"Checking out Source of the Android base","text":"<p>Our build process is based around the Android source tree, but where needed we've modified some projects, in order to apply patches required to make libhybris function correctly, and to minimise the built-in actions and services in the <code>init.*.rc</code> files.</p> <p>Ensure you have setup your name and e-mail address in your Git configuration:</p> HABUILD SDK<pre><code>git config --global user.name \"Your Name\"\ngit config --global user.email \"you@example.com\"\n</code></pre> <p>Ensure Ubuntu chroot has cpio installed:</p> HABUILD SDK<pre><code>sudo apt-get install cpio\n</code></pre> <p>You also need to install the <code>repo</code> command from the AOSP source code repositories, see Installing repo.</p> <p>Note</p> <p>If your port requires openjdk 17 or older, use the older repo tool for legacy Python 2 systems.</p> <p>After you have installed the <code>repo</code> command, a set of commands below will download the required projects for building the modified parts of the Android base used in Sailfish OS hardware adaptations.</p> <p>All available Android base variants and versions that you can port on can be seen here: https://github.com/mer-hybris/android/branches</p> <p>Choose a version which has the best hardware support for your device.</p> <p>Alternatively, you can patch an Android base of your choosing (e.g. be it CAF or AOSP or another).</p> <p>The result of your Sailfish OS port will be an installable ZIP file. Before deploying it onto your device, you'll have to flash a corresponding version of the Android base, so Sailfish OS can re-use its Android HAL shared objects.</p> <p>If your primary ROM does not match your Android base or its version, and you would like to keep it on your device, then look for MultiROM support for it. Starting with its version v28, it supports booting Sailfish OS.</p> <p>This porting guide is using Nexus 5 and CyanogenMod 11.0 version as example:</p> HABUILD SDK<pre><code>sudo mkdir -p $ANDROID_ROOT\nsudo chown -R $USER $ANDROID_ROOT\ncd $ANDROID_ROOT\nrepo init -u https://github.com/mer-hybris/android.git -b hybris-11.0\n</code></pre>"},{"location":"android/#device-repos","title":"Device repos","text":"<p>The local manifest contains device-specific repositories, for Android as well as for the mer-hybris builds.</p> <p>If your device has already been ported, its codes properly placed on GitHub, you should check this repository: https://github.com/mer-hybris/local_manifests (choose the branch of hybris-* that your are porting to), and use $DEVICE.xml file instead of creating a new one in this chapter.</p> <p>Create directory at first:</p> HABUILD SDK<pre><code>mkdir $ANDROID_ROOT/.repo/local_manifests\n</code></pre> <p>If your are working on a new port, you'll have to create the local manifest yourself, which contains at least two repos: one for the kernel, another for the device configuration. Find those in the LineageOS device wiki, for Nexus 5 it would be https://wiki.lineageos.org/devices/hammerhead/build#initialize-the-lineageos-source-repository Local manifest below will also need pointing to correct branches - identify which one matches the default manifest branch (<code>stable/cm-11.0</code> in Nexus 5 case).</p> <p>Add the following content to <code>$ANDROID_ROOT/.repo/local_manifests/$DEVICE.xml</code>:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;manifest&gt;\n  &lt;project path=\"device/lge/hammerhead\"\n    name=\"CyanogenMod/android_device_lge_hammerhead\"\n    revision=\"stable/cm-11.0\" /&gt;\n  &lt;project path=\"kernel/lge/hammerhead\"\n    name=\"CyanogenMod/android_kernel_lge_hammerhead\"\n    revision=\"stable/cm-11.0\" /&gt;\n&lt;/manifest&gt;\n</code></pre> <p>Time to sync the whole source code, this might take a while: Do not use <code>--fetch-submodules</code> parameter on hybris-18.1 or newer Android bases.</p> HABUILD SDK<pre><code>repo sync --fetch-submodules\n</code></pre> <p>The expected disk usage for the source tree after the sync is 13 GB (as of 2015-09-09, hybris-11.0 branch). Depending on your connection, this might take some time. In the mean time, make yourself familiar with the rest of this guide.</p>"},{"location":"android/#configure-mountpoint-information","title":"Configure Mountpoint Information","text":"<p>Currently in Sailfish OS, <code>udev</code> starts after <code>initrd</code>, which leaves us not being able to use generic partition names (independent of partition number).</p> <p>In <code>initrd</code> we then have to specify hardcoded <code>/dev/mmcblkXpY</code> nodes for <code>/boot</code> and <code>/data</code> partitions.</p> <p>After <code>initrd</code>, <code>systemd</code> needs to mount all other required partitions (such as <code>/system</code>, <code>/firmware</code>, <code>/persist</code>, <code>/config</code>, ...) for the HAL layer to work. The required partitions are read from <code>*.fstab</code> and <code>init*.rc</code> files, disabled there, and respective <code>.mount</code> units created -- all done by <code>$ANDROID_ROOT/rpm (droid-hal-device)</code>.</p> <p>Unfortunately, <code>systemd</code> cannot recognise named partition paths in <code>.mount</code> units, because of the same late start of <code>udev</code>, even though one can see already created nodes under <code>/dev/block/platform/*/by-name/</code> or <code>/dev/block/platform/*/*/by-name</code>.</p> <p>To work around this, we need to create a map between partition names and numbers in <code>hybris/hybris-boot/fixup-mountpoints</code> for each device, for all partitions -- in this way we are sure to cover them all, because if done manually by looking through fstab/rc files, some might get unnoticed.</p> <p>To get that mapping, you should flash and boot an image of your Android base and execute <code>adb shell</code> on your host and something like this: <code>ls -l /dev/block/platform/*/by-name/</code> on your device. To get the correct path you must find Android's fstab in device repository or in device itself and get by-name path like: <code>block/bootdevice/by-name/userdata</code>, <code>ls -l /dev/block/platform/*/*/by-name/</code>or <code>block/platform/*/by-name/userdata</code> from it.</p> <p>Once you've patched <code>fixup-mountpoints</code>, take care if you ever have to run <code>repo sync --fetch-submodules</code> again because it will reset your changes, unless the file <code>.repo/local_manifests/$DEVICE.xml</code> is pointing <code>hybris-boot</code> to your fork with the needed fixup-mountpoints changes.</p> <p>Then when you get to boot to the Sailfish OS UI, please don't forget to upstream your <code>fixup-mountpoints</code> patch.</p>"},{"location":"android/#building-relevant-bits-of-your-android-base","title":"Building Relevant Bits of your Android base","text":"<p>In the Android build tree, run the following in a <code>bash</code> shell (if you are using e.g. <code>zsh</code>, you need to run these commands in a <code>bash</code> shell, as the Android build scripts are assuming you are running <code>bash</code>).</p> <p>You'll probably need to iterate this a few times to spot missing repositories, tools, configuration files and others:</p> <p>Before building it is recommended to read extra Android base specific hints from https://github.com/mer-hybris/hadk-faq#android-base-specific-fixes</p> HABUILD SDK<pre><code>source build/envsetup.sh\nexport USE_CCACHE=1\n\nbreakfast $DEVICE\n\nmake -j$(nproc --all) hybris-hal droidmedia\n</code></pre> <p>The relevant output bits will be in <code>out/target/product/$DEVICE/</code>, in particular:</p> <ul> <li><code>hybris-boot.img</code>: Kernel and initrd</li> <li><code>hybris-recovery.img</code>: Recovery boot image</li> <li><code>system/</code> and <code>root/</code>: HAL system libraries and binaries</li> </ul> <p>The approximate size of the output directory <code>out/</code> after <code>make hybris-hal</code> is 10 GB (as of 2019-03-14, hybris-sony-aosp-8.1.0_r52-20190206 branch).</p>"},{"location":"android/#kernel-config","title":"Kernel config","text":"<p>Once the kernel has built you can check the kernel config. You can use the Mer kernel config checker:</p> HABUILD SDK<pre><code>cd $ANDROID_ROOT\n\nhybris/mer-kernel-check/mer_verify_kernel_config \\\n    ./out/target/product/$DEVICE/obj/KERNEL_OBJ/.config\n</code></pre> <p>Apply listed modifications to the defconfig file that your Android base is using. Which one? It's different for every device, most likely first:</p> <ul> <li>Check the value of <code>TARGET_KERNEL_CONFIG</code> under   <code>$ANDROID_ROOT/device/$VENDOR/*/BoardConfig*.mk</code></li> <li> <p>Examine the output of <code>make bootimage</code> for which defconfig is taken when   you're building kernel, e.g.:</p> <pre><code>make  -C kernel/lge/hammerhead ... cyanogenmod_hammerhead_defconfig\n</code></pre> </li> <li> <p>Check your Android base kernel's commit history for the   <code>arch/arm*/configs</code> folder, look for defconfig</p> </li> </ul> <p>If you are in a rush, get rid only of <code>ERROR</code> cases first, but don't forget to come back to the <code>WARNING</code> ones too. After you'll have applied the needed changes, re-run <code>make hybris-boot</code> and re-verify. Lather, rinse, repeat :) Run also <code>make hybris-recovery</code> in the end when no more errors.</p>"},{"location":"android/#contribute-your-mods-back","title":"Contribute your mods back","text":"<p>Fork the kernel repo to your GitHub home (indicated by <code>myname</code> in this doc).</p> <p>For Nexus 5 with CM 11.0 as base, the next action would be (rename where appropriate to match your device/branch):</p> HABUILD SDK<pre><code>cd kernel/lge/hammerhead\ngit checkout -b hybris-11.0\n\nDEFCONFIG=arch/arm/configs/cyanogenmod_hammerhead_defconfig\n\ngit add $DEFCONFIG\n\ngit commit -m \"Hybris-friendly defconfig\"\ngit remote add myname https://github.com/myname/android_kernel_lge_hammerhead\ngit push myname hybris-11.0\n</code></pre> <p>Create PR to the forked kernel repo under github/mer-hybris. Ask a mer-hybris admin to create one, if it isn't there.</p> <p>Adjust your <code>.repo/local_manifests/$DEVICE.xml</code> by replacing the line</p> <pre><code>&lt;project path=\"kernel/lge/hammerhead\"\n  name=\"CyanogenMod/android_kernel_lge_hammerhead\"\n  revision=\"stable/cm-11.0-XNG3C\" /&gt;\n</code></pre> <p>with</p> <pre><code>&lt;project path=\"kernel/lge/hammerhead\"\n  name=\"myname/android_kernel_lge_hammerhead\"\n  revision=\"hybris-11.0\" /&gt;\n</code></pre>"},{"location":"android/#common-pitfalls","title":"Common Pitfalls","text":"<ul> <li> <p>If <code>repo sync --fetch-submodules</code> fails with a message like   <pre><code>fatal: duplicate path device/samsung/smdk4412-common in /home/nemo/android/.repo/manifest.xml\n</code></pre>   remove the local manifest with <code>rm .repo/local_manifests/roomservice.xml</code></p> </li> <li> <p>If <code>repo sync --fetch-submodules</code> fails with some other error message, try   running <code>repo sync</code> to see if it helps. This is usually needed for   hybris-18.1 or newer Android bases.</p> </li> <li> <p>If you notice <code>git clone</code> commands starting to write out \"Forbidden ...\"   on github repos, you might have hit API rate limit. To solve this, put your   github credentials into <code>~/.netrc</code>.   More info can be found following this link:   Perm.auth. with Git repositories</p> </li> <li> <p><code>error: Cannot fetch ... (GitError: --force-sync not enabled; cannot overwrite a local work tree.</code>   usually happens if <code>repo sync --fetch-submodules</code> gets interrupted.   It is a bug of the repo tool. Ensure all your changes have been safely stowed   (check with <code>repo status</code>), and then workaround by:   HABUILD SDK<pre><code>repo sync --force-sync\nrepo sync --fetch-submodules\n</code></pre></p> </li> <li> <p>In some cases (with parallel builds), the build can fail, in this   case, use <code>make -j1 ...</code> to retry with a non-parallel build and see   the error message without output from parallel jobs. The build   usually ends with the following output:   HABUILD SDK<pre><code>...\nInstall: .../out/target/product/$DEVICE/hybris-recovery.img\n...\nInstall: .../out/target/product/$DEVICE/hybris-boot.img\n</code></pre></p> </li> </ul>"},{"location":"build-env/","title":"Installing Build Tools for Your Device","text":"<p>It is necessary to emulate your target device architecture and file system to build hardware adaptation packages in the next section. Download and install your build tools following instructions below.</p> <p>Important</p> <p>Minimum version for SFOS target is 4.3.0.15 (same requirement as for the Platform SDK Chroot earlier)</p> <p>Warning</p> <p>To ensure consistency with HADK build scripts, name your tooling <code>SailfishOS-4.5.0</code> (or whichever release you are building for) instead of suggested <code>SailfishOS-latest</code>, and your target as <code>$VENDOR-$DEVICE-$PORT_ARCH</code> (instead of <code>SailfishOS-latest-aarch64</code>). Ignore the i486 target.</p> <p>For ARM devices, choose <code>aarch64</code> build target, unless you are building for the <code>armv7hl</code> Sailfish OS userspace.</p> <p>https://docs.sailfishos.org/Tools/Platform_SDK/Target_Installation/</p> <p>To verify the correct installation of the build tools, cross-compile a simple \"Hello, World!\" C application with <code>mb2 build-shell</code>:</p> PLATFORM SDK<pre><code>cd $HOME\nmkdir hadk-test-tmp\ncd hadk-test-tmp\ncat &gt; main.c &lt;&lt; EOF\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n  printf(\"Hello, world!\\n\");\n  return EXIT_SUCCESS;\n}\nEOF\nmb2 -t $VENDOR-$DEVICE-$PORT_ARCH build-init\nmb2 -t $VENDOR-$DEVICE-$PORT_ARCH build-shell gcc main.c -o test\n</code></pre> <p>If the compilation was successful you can test the executable by running the following command (this will run the executable using <code>qemu</code> as emulation layer, which is part of the <code>mb2</code> setup):</p> PLATFORM SDK<pre><code>mb2 -t $VENDOR-$DEVICE-$PORT_ARCH build-shell ./test\n</code></pre> <p>The above command should output \"Hello, world!\" on the console, this proves that the build tools can compile binaries and execute them for your architecture.</p>"},{"location":"droid-hal/","title":"Packaging Droid HAL","text":"<p>In this chapter, we will package the build results of building the Android HAL as RPM packages and create a local RPM repository. From there, the RPM packages can be added to a local target and used to build libhybris and the QPA plugin. They can also be used to build the rootfs.</p>"},{"location":"droid-hal/#creating-repositories-for-a-new-device","title":"Creating Repositories for a New Device","text":"<p>If the folders <code>rpm, hybris/droid-configs, hybris-droid-hal-version-$DEVICE</code> do not exist yet, create them as follows (example is for Nexus 5, adjust as appropriate and push to your GitHub home):</p> PLATFORM SDK<pre><code>cd $ANDROID_ROOT\nmkdir rpm\ncd rpm\ngit init\ngit submodule add https://github.com/mer-hybris/droid-hal-device dhd\n# Rename 'hammerhead' and other values as appropriate\nsed -e \"s/@DEVICE@/hammerhead/\" \\\n    -e \"s/@VENDOR@/lge/\" \\\n    -e \"s/@DEVICE_PRETTY@/Nexus 5/\" \\\n    -e \"s/@VENDOR_PRETTY@/LG/\" \\\n    dhd/droid-hal-@DEVICE@.spec.template &gt; droid-hal-hammerhead.spec\n# Please review droid-hal-hammerhead.spec before committing!\ngit add .\ngit commit -m \"[dhd] Initial content\"\n# Create this repository under your GitHub home\ngit remote add myname https://github.com/myname/droid-hal-hammerhead.git\ngit push myname master\ncd -\n\nmkdir -p hybris/droid-configs\ncd hybris/droid-configs\ngit init\ngit submodule add https://github.com/mer-hybris/droid-hal-configs \\\n    droid-configs-device\nmkdir rpm\nsed -e \"s/@DEVICE@/hammerhead/\" \\\n    -e \"s/@VENDOR@/lge/\" \\\n    -e \"s/@DEVICE_PRETTY@/Nexus 5/\" \\\n    -e \"s/@VENDOR_PRETTY@/LG/\" \\\n    droid-configs-device/droid-config-@DEVICE@.spec.template &gt; \\\n    rpm/droid-config-hammerhead.spec\n# Please review rpm/droid-config-hammerhead.spec before committing!\ngit add .\ngit commit -m \"[dcd] Initial content\"\n# Create this repository under your GitHub home\ngit remote add myname https://github.com/myname/droid-config-hammerhead.git\ngit push myname master\ncd -\n\nrpm/dhd/helpers/add_new_device.sh\n# On Nexus 5 the output of the last command is:\n# Creating the following nodes:\n# sparse/\n# patterns/\n# patterns/jolla-configuration-hammerhead.yaml\n# patterns/jolla-hw-adaptation-hammerhead.yaml\ncd hybris/droid-configs\ngit add .\ngit commit -m \"[dcd] Patterns and compositor config\"\ngit push myname master\ncd -\n\nmkdir -p hybris/droid-hal-version-hammerhead\ncd hybris/droid-hal-version-hammerhead\ngit init\ngit submodule add https://github.com/mer-hybris/droid-hal-version\nmkdir rpm\nsed -e \"s/@DEVICE@/hammerhead/\" \\\n    -e \"s/@VENDOR@/lge/\" \\\n    -e \"s/@DEVICE_PRETTY@/Nexus 5/\" \\\n    -e \"s/@VENDOR_PRETTY@/LG/\" \\\n    droid-hal-version/droid-hal-version-@DEVICE@.spec.template &gt; \\\n    rpm/droid-hal-version-hammerhead.spec\n# Please review rpm/droid-hal-version-hammerhead.spec before committing!\ngit add .\ngit commit -m \"[dvd] Initial content\"\n# Create this repository under your GitHub home\ngit remote add myname \\\n    https://github.com/myname/droid-hal-version-hammerhead.git\ngit push myname master\n</code></pre> <p>Now to complete you local manifest, this is how it would be done for Nexus 5. Do it for your device by renaming accordingly.</p> <p>Add the next 3 entries into <code>.repo/local_manifests/hammerhead.xml</code></p> <pre><code>&lt;project path=\"rpm/\"\n         name=\"myname/droid-hal-hammerhead\" revision=\"master\" /&gt;\n&lt;project path=\"hybris/droid-configs\"\n         name=\"myname/droid-config-hammerhead\" revision=\"master\" /&gt;\n&lt;project path=\"hybris/droid-hal-version-hammerhead\"\n         name=\"myname/droid-hal-version-hammerhead\" revision=\"master\" /&gt;\n</code></pre> <p>Once all these 3 repositories get upstreamed under https://github.com/mer-hybris create PR into an appropriate branch of the file <code>.repo/local_manifests/hammerhead.xml</code> to the https://github.com/mer-hybris/local_manifests repository.</p>"},{"location":"droid-hal/#packaging-droid-hal-device","title":"Packaging <code>droid-hal-device</code>","text":"<p>The <code>$ANDROID_ROOT/rpm/</code> dir contains the needed <code>.spec</code> file to make a set of RPM packages that form the core Droid hardware adaptation part of the hardware adaptation. It also builds a development package (ends with -devel) that contains libraries and headers, which are used when building middleware components later on.</p>"},{"location":"droid-hal/#building-the-droid-hal-device-packages","title":"Building the droid-hal-device packages","text":"<p>Before building the packages it is recommended to read extra Android base specific hints from https://github.com/mer-hybris/hadk-faq#android-base-specific-fixes</p> <p>The next step has to be carried out in the Platform SDK chroot:</p> PLATFORM SDK<pre><code>cd $ANDROID_ROOT\n\nrpm/dhd/helpers/build_packages.sh --droid-hal\nrpm/dhd/helpers/build_packages.sh --configs\nrpm/dhd/helpers/build_packages.sh --mw\nrpm/dhd/helpers/build_packages.sh --gg\nrpm/dhd/helpers/build_packages.sh --version\n</code></pre> <p>This will compile all the needed packages, patterns, middleware and put them under local repository. If anything gets modified, just re-run the appropriate part.</p>"},{"location":"droid-hal/#troubleshoot-errors-from-build_packagessh","title":"Troubleshoot errors from build_packages.sh","text":"<ul> <li> <p>Installed (but unpackaged) file(s) found: Add those files to   straggler section in your <code>rpm/droid-hal-$DEVICE.spec</code> before the   <code>%include ...</code> line, for example:   <pre><code>%define straggler_files \\\n/init.mmi.boot.sh\\\n/init.mmi.touch.sh\\\n/init.qcom.ssr.sh\\\n/selinux_version\\\n/service_contexts\\\n%{nil}\n</code></pre></p> </li> <li> <p>Lastly, re-run <code>build_packages.sh --droid-hal</code></p> </li> </ul>"},{"location":"factory/","title":"Addendum: Factory Productisation","text":"<p>This chapter explains the next steps towards the mass-production of a product, after all HW peripheral functions are in working order.</p> <p>This includes:</p> <ul> <li>Package <code>system</code> partition content as RPM</li> <li>Flash Sailfish OS to use the whole <code>userdata</code> partition as LVM</li> <li>Enable Sailfish OS recovery mode</li> <li>Enable factory reset support</li> <li>Provide flashing tools</li> <li>Modify bootloader, splash screen, and other partitions</li> <li>Optimising size and layout of partitions</li> <li>Provide a raw image for factory testing and flashing</li> </ul>"},{"location":"factory/#package-system-partition","title":"Package <code>system</code> partition","text":"<p>Sailfish OS needs a mounted <code>system</code> partition under <code>/system</code> to use the underlying Android parts.</p> <p>However to provide BSP updates that an ODM may give, its content needs to be packaged as RPM and deployed in <code>userdata</code> together with the rest of our rootfs.</p> <p>In this way we get to win free space by removing unused files, and use <code>system</code> partition for e.g. flashing the factory reset image.</p> <p>At first create a tarball of the original <code>/system</code> contents from the Android base image flashed to your device (we are using Nexus 5 in this guide).</p> <p>Transfer the tarball to your host and extract it.</p> <p>Alternatively you may have a ready-built <code>system.img</code> from the original Android build, the file snippet below explains how to extract it.</p> <p>Create directory <code>$ANDROID_ROOT/hybris/droid-system/</code> and create file <code>copy_system.sh</code> with the following content:</p> <pre><code>#\n# Use this script everytime you receive an updated /system from your ODM.\n#\n# Before running this script please extract raw system image\n# and mount loop image to some mount point. Give that mount point\n# parameter for this script.\n#\n# 1. \"simg2img system.img system.raw\" (Run inside Platform SDK target)\n# 2. \"mkdir ~/system\"\n# 3. \"sudo mount -t ext4 -o loop system.raw ~/system\"\n# 4. \"./copy_system.sh ~/system\"\n\nif [ -z \"$1\" ]; then\n  echo \"No argument supplied, try $0 ~/path/to/system\"\n  exit\nfi\n\nSYSTEM_SPARSE=\"sparse/system\"\nSYSTEM_MOUNT=$1\n\n# Add read permission for some binaries under system mount\nsudo chmod a+r $SYSTEM_MOUNT/bin/netcfg\nsudo chmod a+r $SYSTEM_MOUNT/bin/run-as\nsudo chmod a+r $SYSTEM_MOUNT/bin/uncrypt\nsudo chmod a+r $SYSTEM_MOUNT/bin/install-recovery.sh\nsudo chmod a+r $SYSTEM_MOUNT/etc/dhcpcd/dhcpcd-run-hooks\n\n# Remove current sparse and create it again\nrm -rf $SYSTEM_SPARSE\nmkdir -p $SYSTEM_SPARSE\n\n# Copy content\necho \"Copy $SYSTEM_MOUNT/* to $SYSTEM_SPARSE\"\ncp -r $SYSTEM_MOUNT/* $SYSTEM_SPARSE\n\n# Remove unused directories and files\nrm -rf $SYSTEM_SPARSE/app/\nrm -rf $SYSTEM_SPARSE/priv-app/\nrm -rf $SYSTEM_SPARSE/media/\nrm -rf $SYSTEM_SPARSE/lib/modules/\nrm -rf $SYSTEM_SPARSE/framework/\nrm -rf $SYSTEM_SPARSE/fonts/\nrm -rf $SYSTEM_SPARSE/usr/keylayout/\nrm -rf $SYSTEM_SPARSE/vendor/app\nrm -rf $SYSTEM_SPARSE/vendor/speccfg\nrm -rf $SYSTEM_SPARSE/vendor/Default/system/media\nrm -rf $SYSTEM_SPARSE/bin/install-recovery.sh\nrm -rf $SYSTEM_SPARSE/recovery-from-boot.p\nrm -rf $SYSTEM_SPARSE/etc/install_apk.sh\nrm -rf $SYSTEM_SPARSE/etc/cdrom_install.iso\nrm -rf $SYSTEM_SPARSE/etc/mmi/fonts.ttf\nrm -rf $SYSTEM_SPARSE/build.prop.bakforspec\nrm -rf $SYSTEM_SPARSE/lib/libchromium_client.so\nrm -rf $SYSTEM_SPARSE/lib/libswenetxt_plugin.so\nrm -rf $SYSTEM_SPARSE/lib/libswewebviewchromium.so\nrm -rf $SYSTEM_SPARSE/lib/libwebviewchromium.so\nrm -rf $SYSTEM_SPARSE/lib/libwebviewchromium_loader.so\nrm -rf $SYSTEM_SPARSE/lib/libwebviewchromium_plat_support.so\nrm -rf $SYSTEM_SPARSE/lib/libWnnJpnDic.so\nrm -rf $SYSTEM_SPARSE/lib/libWnnEngDic.so\nrm -rf $SYSTEM_SPARSE/lib/libpac.so\nrm -rf $SYSTEM_SPARSE/lib/libjni_pacprocessor.so\nrm -rf $SYSTEM_SPARSE/lib/libswev8.so\nrm -rf $SYSTEM_SPARSE/lib/libsweskia.so\nrm -rf $SYSTEM_SPARSE/usr/qfipsverify/bootimg.hmac\nrm -rf $SYSTEM_SPARSE/etc/recovery-resource.dat\nrm -rf $SYSTEM_SPARSE/etc/security/otacerts.zip\nrm -rf $SYSTEM_SPARSE/vendor/bin/slim_ap_daemon\n\n# If you want to make customisations to your /system, create ./patches\n# directory and apply them below, e.g.:\n#echo \"Patch Jolla changes on top of ODM's delivery:\"\n#patch -p1 &lt; patches/0001-bug-Don-t-use-GPS-Sensor-Assisted-Positioning.patch\n</code></pre> <p>Afterwards execute <code>copy_system.sh ~/path/to/system</code> ensuring you point to files within directory as opposed to a path that contains <code>system/</code> directory itself.</p> <p>Now you have a reduced yet functional (tested on Nexus 5, Jolla C/Aqua Fish, and Turing Phone) <code>system</code> under <code>./sparse/system</code> that will be packaged as follows:</p> <p>Create path and file <code>$ANDROID_ROOT/hybris/droid-system/rpm/droid-system-hammerhead.spec</code> with content:</p> <pre><code>%define device hammerhead\n\n%define dsd_path ./\n\n%include droid-system-device/droid-system.inc\n</code></pre> <p>And <code>$ANDROID_ROOT/hybris/droid-system/droid-system-device/droid-system.inc</code> with:</p> <p>Important</p> <p>We shall provide access to Git repo containing this file in due time, then you'll be able to use it as submodule for maximum code re-use, minimising fragmentation.</p> <pre><code>%define __find_provides %{nil}\n%define __find_requires %{nil}\n%define __strip /bin/true\n%define __provides_exclude_from ^/system/.*$\n%define __requires_exclude ^.*$\n%global debug_package %{nil}\n\n%if 0%{!?rpm_device:1}\n%define rpm_device %{device}\n%endif\n\nName:       droid-system-%{rpm_device}\nProvides:   droid-system\nSummary:    System package for Droid HAL adaptations\nVersion:    1\nRelease:    1\nGroup:      Development/Tools\nLicense:    Proprietary\nSource0:    %{name}-%{version}.tar.bz2\n%description\n%{summary}.\n\n%prep\n%if 0%{?_obs_build_project:1}\n# For OBS builds we need to have tarball extracted after tar_git packaging it\n%setup -q -n %{name}-%{version}\n%endif\n\n%install\nrm -rf %{buildroot}\nmkdir -p %{buildroot}\n\n# Retain permissions:\nrm -rf tmp/\nmkdir -p tmp/\necho \"%defattr(-,root,root,-)\" &gt; tmp/droid-system.files\n\n# Prefer files from sparse/ in the HA specific\n# area over sparse/ in the dsd area\ncopy_files_from() {\n  source_dir=$1\n  if [ -d $source_dir ]; then\n    (cd $source_dir; find . \\( -type f -or -type l \\) -print ) | sed 's/^.//' &gt;&gt; tmp/droid-system.files\n    cp -R $source_dir/* $RPM_BUILD_ROOT/\n  fi\n}\n\ndelete_files() {\n  files=$1\n  deletelist=$2\n  dorm=$3\n  if [ -e $deletelist ]; then\n    egrep -v '^#' $deletelist | (\n      while read file; do\n        [ \"x$dorm\" == \"x1\" ] &amp;&amp; rm $RPM_BUILD_ROOT/$file\n        grep -vE \"$file\" $files &gt; tmp/$$.files\n        mv tmp/$$.files $files\n      done)\n  fi\n}\n\n# Copy from sparse; erase any we don't want\ncopy_files_from %{dsd_path}/sparse\ndelete_files tmp/droid-system.files delete_file.list 1\n\n%files -f tmp/droid-system.files\n%defattr(-,root,root,-)\n</code></pre> <p>Thereafter, build the package:</p> PLATFORM SDK<pre><code>cd $ANDROID_ROOT\nrpm/dhd/helpers/build_packages.sh --build=hybris/droid-system\n</code></pre> <p>And effectively enable our home-grown /system in <code>$ANDROID_ROOT/rpm</code>:</p> <pre><code>diff --git a/droid-hal-$DEVICE.spec b/droid-hal-$DEVICE.spec\n+%define makefstab_skip_entries /system\n+Requires: droid-system\n+\n %include rpm/dhd/droid-hal-device.inc\n</code></pre> <p>Rebuild dhd via <code>rpm/dhd/helpers/build_packages.sh --droid-hal</code> and then the whole image (refer to mic).</p>"},{"location":"factory/#convert-userdata-into-the-sailfish-os-lvm-partition","title":"Convert <code>userdata</code> into the Sailfish OS LVM partition","text":"<p>We want to split <code>$HOME</code> and <code>/</code> into separate volumes, so we could e.g. <code>/</code>, or encrypt <code>$HOME</code>. For this we\\'ll use the whole <code>userdata</code> as an LVM partition, with fixed size <code>/</code> and let <code>$HOME</code> take up the rest.</p>"},{"location":"factory/#package-an-lvm-enabled-bootloader","title":"Package an LVM-enabled bootloader","text":"<p>In directory <code>$ANDROID_ROOT/rpm</code> apply the following:</p> <pre><code>diff --git a/droid-hal-$DEVICE.spec b/droid-hal-$DEVICE.spec\n-%define installable_zip 1\n+%define have_custom_img_boot 1\n+%define have_custom_img_recovery 1\n</code></pre> <p>And rebuild droid-hal <code>rpm/dhd/helpers/build_packages.sh --droid-hal</code>.</p> <p>Then create path and file <code>$ANDROID_ROOT/hybris/droid-hal-img-boot/rpm/droid-hal-hammerhead-img-boot.spec</code> with content:</p> <pre><code>%define device hammerhead\n\n# Retrieve mkbootimg_cmd contents from\n# $ANDROID_ROOT/device/$VENDOR/$DEVICE/BoardConfig.mk and/or from make output.\n# NOTE: taken from the userdebug build, check after switching to user build!\n# If your Android adaptation produces a separate device tree, it should be\n# packaged within droid-hal-$DEVICE-kernel .rpm as ./boot/dt.img, add this to\n# mkbootimg_cmd: --dt %{devicetree}\n%define mkbootimg_cmd mkbootimg --ramdisk %{initrd} --kernel %{kernel} --base 0x00000000 --pagesize 2048 --ramdisk_offset 0x02900000 --tags_offset 0x02700000 --cmdline \"androidboot.hardware=hammerhead user_debug=31 msm_watchdog_v2.enable=1 selinux=0\"  --output\n\n%define root_part_label userdata\n%define factory_part_label system\n\n%define display_brightness_path /sys/class/leds/lcd-backlight/brightness\n%define display_brightness 16\n\n%include initrd/droid-hal-device-img-boot.inc\n</code></pre> <p>Initiate git repository with our publicly available <code>hybris-initrd</code> as submodule; then build dependencies and the new img-boot:</p> PLATFORM SDK<pre><code>cd $ANDROID_ROOT/hybris/droid-hal-img-boot\ngit init\ngit submodule add https://github.com/mer-hybris/hybris-initrd initrd\n\ncd $ANDROID_ROOT\nsdk-assistant maintain $VENDOR-$DEVICE-$PORT_ARCH zypper in droid-hal-$DEVICE-kernel droid-hal-$DEVICE-kernel-modules\nrpm/dhd/helpers/build_packages.sh --build=hybris/droid-hal-img-boot/\n\n# Test the success by booting our recovery image (boot image would not boot\n# without LVM yet):\nrpm2cpio droid-local-repo/$DEVICE/droid-hal-img-boot/droid-hal-$DEVICE-img-recovery-*.armv7hl.rpm | cpio -idv\n# Set your device into fastboot mode:\nsudo fastboot boot ./boot/hybris-recovery.img\n\n# Shortly you should see instructions on device screen on how to telnet in,\n# however avoid testing factory reset, as it is not ready at this stage.\n</code></pre>"},{"location":"factory/#configuring-the-lvm-packaging","title":"Configuring the LVM packaging","text":"<p>Within <code>$ANDROID_ROOT/hybris/droid-configs</code> create the following paths and files:</p> kickstart/pack/$DEVICE/hybris<pre><code>pushd $IMG_OUT_DIR\n\nMD5SUMFILE=md5.lst\n\nDEVICE_VERSION_FILE=./hw-release\n\nEXTRA_NAME=\"\"\n\nif [ -n \"@EXTRA_NAME@\" ] &amp;&amp; [ \"@EXTRA_NAME@\" != @\"EXTRA_NAME\"@ ]; then\n  EXTRA_NAME=\"@EXTRA_NAME@-\"\nfi\n\nDEVICE=\"\"\nDEVICE_VERSION=\"\"\n\nif [[ -a $DEVICE_VERSION_FILE ]]; then\n  source $DEVICE_VERSION_FILE\n  DEVICE=$MER_HA_DEVICE\n  DEVICE_VERSION=-$VERSION_ID\nfi\n\nsource ./sailfish-release\nif [ \"$SSU_RELEASE_TYPE\" = \"rnd\" ]; then\n  RELEASENAME=$NAME-${EXTRA_NAME// /_}$SAILFISH_FLAVOUR-$VERSION_ID-$DEVICE$DEVICE_VERSION\nelse\n  RELEASENAME=$NAME-${EXTRA_NAME// /_}$VERSION_ID-$DEVICE$DEVICE_VERSION\nfi\n\n# Setup LVM image\ndd if=/dev/zero bs=1 count=0 of=temp.img seek=3000M\nLVM_LOOP=$(/sbin/losetup -f)\n/sbin/losetup $LVM_LOOP temp.img\n/usr/sbin/pvcreate $LVM_LOOP\n/usr/sbin/vgcreate sailfish $LVM_LOOP\n\n# Resize root and home to minimum\nROOT_LOOP=$(/sbin/losetup -f)\n/sbin/losetup $ROOT_LOOP root.img\n/sbin/e2fsck -f -y $ROOT_LOOP\nBLOCKS=$(/sbin/resize2fs -M $ROOT_LOOP | /bin/grep \"The filesystem on\" | /bin/cut -d ' ' -f 7)\necho We got ourselves root blocks _ $BLOCKS _\nSIZE=$(/usr/bin/expr $BLOCKS \\* 4096)\necho after maths size _ $SIZE _\n/usr/sbin/lvcreate -L ${SIZE}B --name root sailfish\n/bin/sync\n/sbin/losetup -d $ROOT_LOOP\n/usr/sbin/vgchange -a y\ndd if=root.img bs=4096 count=$BLOCKS of=/dev/sailfish/root\n\n\nHOME_LOOP=$(/sbin/losetup -f)\n/sbin/losetup $HOME_LOOP home.img\n/sbin/e2fsck -f -y $HOME_LOOP\nBLOCKS=$(/sbin/resize2fs -M $HOME_LOOP | /bin/grep \"The filesystem on\" | /bin/cut -d ' ' -f 7)\necho We got ourselves home size _ $BLOCKS _\nSIZE=$(/usr/bin/expr $BLOCKS \\* 4096)\n\n/usr/sbin/lvcreate -L ${SIZE}B --name home sailfish\n/bin/sync\n/sbin/losetup -d $HOME_LOOP\n/usr/sbin/vgchange -a y\ndd if=home.img bs=4096 count=$BLOCKS of=/dev/sailfish/home\n\n/usr/sbin/vgchange -a n sailfish\n\nrm home.img root.img\n\n/sbin/losetup -d $LVM_LOOP\n\nmv temp.img sailfish.img\n\n/usr/bin/atruncate sailfish.img\n\nchmod 755 flash.*\n\nFILES=\"flash* *.img* *-release\"\nFILES_TO_COPY=\"*.urls\"\n\nmkdir -p ${RELEASENAME}\ncp ${FILES_TO_COPY} ${RELEASENAME}/\nmv ${FILES} ${RELEASENAME}/\n\n# Calculate md5sums of files included to the tarball\ncd ${RELEASENAME}\nmd5sum * &gt; $MD5SUMFILE\ncd ..\n\n# Package stuff back to tarball\ntar -cjf ${RELEASENAME}.tar.bz2 $RELEASENAME\n\n# Remove the files from the output directory\nrm -r ${RELEASENAME}\n\npopd\n</code></pre> kickstart/part/$DEVICE<pre><code>part / --fstype=\"ext4\" --size=1800 --label=root\npart /home --fstype=\"ext4\" --size=800 --label=home\n</code></pre> kickstart/attachment/$DEVICE<pre><code>/boot/hybris-boot.img\n/boot/hybris-recovery.img\ndroid-config-hammerhead-out-of-image-files\n/etc/hw-release\n</code></pre> out-of-image-files.files<pre><code>/boot/flash.sh\n/boot/extracting-README.txt\n/boot/flashing-README.txt\n</code></pre> sparse/boot/flash.sh<pre><code>#!/bin/bash\n\n# Contact: Marko Saukko &lt;marko.saukko@jollamobile.com&gt;\n#\n# Copyright (c) 2016, Jolla Ltd.\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n# * Redistributions of source code must retain the above copyright\n# notice, this list of conditions and the following disclaimer.\n# * Redistributions in binary form must reproduce the above copyright\n# notice, this list of conditions and the following disclaimer in the\n# documentation and/or other materials provided with the distribution.\n# * Neither the name of the &lt;organization&gt; nor the\n# names of its contributors may be used to endorse or promote products\n# derived from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY\n# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nset -e\n\nfunction check_fastboot {\n  FASTBOOT_BIN_NAME=$1\n  if [ -f \"$FASTBOOT_BIN_NAME\" ]; then\n    chmod 755 $FASTBOOT_BIN_NAME\n    # Ensure that the binary that is found can be executed fine\n    if ./$FASTBOOT_BIN_NAME help &amp;&gt;/dev/null; then\n      FASTBOOT_BIN_PATH=\"./\"\n      return 0\n    fi\n  fi\n  return 1\n}\n\n\n# Do not need root for fastboot on Mac OS X\nif [ \"$(uname)\" != \"Darwin\" -a $(id -u) -ne 0 ]; then\n  exec sudo -E bash $0\nfi\n\nUNAME=$(uname)\nOS_VERSION=\n\ncase $UNAME in\n  Linux)\n    echo \"Detected Linux\"\n    ;;\n  Darwin)\n    IFS='.' read -r major minor patch &lt;&lt;&lt; $(sw_vers -productVersion)\n    OS_VERSION=$major-$minor\n    echo \"Detected Mac OS X - Version: $OS_VERSION\"\n    ;;\n  *)\n    echo \"Failed to detect operating system!\"\n    exit 1\n    ;;\nesac\n\nVENDORIDLIST=(\n\"18d1\"\n)\n\necho \"Searching device to flash..\"\nIFS=$'\\n'\nif [ \"$UNAME\" = \"Darwin\" ]; then\n  # Mac OS X: Use System Profiler, get only the Vendor IDs and\n  # append a colon at the end to make the lsusb-specific grep\n  # from below work the same way as on Linux.\n  LSUSB=( $(system_profiler SPUSBDataType | \\\n      grep -o 'Vendor ID: [x0-9a-f]*' | \\\n      sed -e 's/$/:/') )\nelse\n  # Linux\n  LSUSB=( $(lsusb) )\nfi\nunset IFS\n\nVENDORIDFOUND=\n\nfor USB in \"${LSUSB[@]}\"; do\n  for VENDORID in ${VENDORIDLIST[@]}; do\n    # : after vendor id is to make sure we don't select based on product id.\n    if [[ \"$USB\" =~ $VENDORID: ]]; then\n      echo \"Found device with vendor id '$VENDORID': $USB\"\n      VENDORIDFOUND=$VENDORID\n    fi\n  done\ndone\n\nif [ -z $VENDORIDFOUND ]; then\n  echo \"No device that can be flashed found. Please connect device to fastboot mode before running this script.\"\n  exit 1\nfi\n\nFASTBOOT_BIN_PATH=\nFASTBOOT_BIN_NAME=\n\nif ! check_fastboot \"fastboot-$UNAME-$OS_VERSION\" ; then\n  if ! check_fastboot \"fastboot-$UNAME\"; then\n    # In case we didn't provide functional fastboot binary to the system\n    # lets check that one is found from the system.\n    if ! which fastboot &amp;&gt;/dev/null; then\n      echo \"No 'fastboot' found in \\$PATH. To install, use:\"\n      echo \"\"\n      echo \"    Debian/Ubuntu/.deb distros:  apt-get install android-tools-fastboot\"\n      echo \"    Fedora:  yum install android-tools\"\n      echo \"    OS X:    brew install android-sdk\"\n      echo \"\"\n      exit 1\n    else\n      FASTBOOT_BIN_NAME=fastboot\n    fi\n  fi\nfi\n\n# TODO: There are cases where the fastboot provided by the system is too old and doesn support\n# for example the erase command below.\n\nFASTBOOTCMD=\"${FASTBOOT_BIN_PATH}${FASTBOOT_BIN_NAME} -i 0x$VENDORIDFOUND $FASTBOOTEXTRAOPTS\"\n\necho \"Fastboot command: $FASTBOOTCMD\"\n\nFLASHCMD=\"$FASTBOOTCMD flash\"\nERASECMD=\"$FASTBOOTCMD erase\"\nABOOTREBOOTCMD=\"$FASTBOOTCMD reboot-bootloader\"\n\nif [ -z ${BINARY_PATH} ]; then\n  BINARY_PATH=./\nfi\n\nif [ -z ${SAILFISH_IMAGE_PATH} ]; then\n  SAILFISH_IMAGE_PATH=./\nfi\n\nIMAGES=(\n\"boot ${SAILFISH_IMAGE_PATH}hybris-boot.img\"\n\"recovery ${SAILFISH_IMAGE_PATH}hybris-recovery.img\"\n)\n\nfor IMAGE in \"${IMAGES[@]}\"; do\n  read partition ifile &lt;&lt;&lt; $IMAGE\n  if [ ! -e ${ifile} ]; then\n    echo \"Image binary missing: ${ifile}.\"\n    exit 1\n  fi\ndone\n\nfor IMAGE in \"${IMAGES[@]}\"; do\n  read partition ifile &lt;&lt;&lt; $IMAGE\n  echo \"Flashing $partition partition..\"\n  $FLASHCMD $partition $ifile\ndone\n\n# Flashing to userdata..\nfor x in sailfish.img*; do\n  $FLASHCMD userdata $x\ndone\n\necho \"Flashing completed. Choose \"Start\" with Volume buttons then press Power.\"\n</code></pre> sparse/boot/flashing-README.txt<pre><code>= FLASHING =\n\nBefore starting flashing on any host turn off the device. After this follow the\ninstructions given for your host PC operating system.\n\nBy this point of time you should already have the .tar.bz2 file that contains\nthe image as this flashing instructions file that you are reading at the moment\nis inside that .tar.bz2 file. As a general note the flashing can take a long\ntime (&gt;10 minutes) and it flashes image with similar name multiple times in the\nend which is expected behaviour.\n\n\n== LINUX ==\n\nOpen terminal application and go to the folder where the image is extracted.\n\nNext:\n* Connect device to computer with USB-cable while holding volume down button\n* When you feel vibra from device you can release the volume down button\n* Next start flashing script by entering following command:\n\n  bash ./flash.sh\n\n* Enter your password if requested to gain root access for flashing the device\n* Once flashing is completed you will see text:\n\n  \"Flashing completed. Detact usb cable, press and hold the powerkey to reboot.\"\n\n* After following the guidance from script device should boot up to new Sailfish OS\n\nNOTE: If flashing does not succeed, you might have missing fastboot binary or\nit is too old. Many distros include andoid-tools package, but that might not\nbe new enough to support tk7001 flashing.\n\nInstallation commands for some linux distributions:\n* Ubuntu: sudo apt-get install android-tools-fastboot\n\nIf you want to compile fastboot binary for your distro you can compile version\n5.0.0 release 7 or newer from:\nhttps://github.com/mer-qa/qa-droid-tools\n</code></pre> sparse/boot/extracting-README.txt<pre><code>Step1: Download the image\n\nThe image name is usually in following format SailfishOS-FLAVOUR-VERSION-DEVICE.tar.bz2\nwhich you need to download.\n\nStep2: Extract the image\n\n= Linux =\n\nFollowing command line extracts the image to the current working directory (pwd):\n\n$ tar -xvf SailfishOS-FLAVOUR-VERSION-DEVICE.tar.bz2\n\nStep3: Read the flashing-README.txt from the extracted directory for further instructions\n</code></pre> <p>Add recovery to patterns and provide flashing script and instructions out of the image:</p> <pre><code>diff --git a/patterns/jolla-hw-adaptation-$DEVICE.yaml b/patterns/jolla-hw-adaptation-$DEVICE.yaml\n - droid-hal-tk7001-img-boot\n+- droid-hal-tk7001-img-recovery\n - droid-hal-tk7001-kernel-modules\n\ndiff --git a/rpm/droid-config-$DEVICE.spec v/rpm/droid-config-$DEVICE.spec\n+%define out_of_image_files 1\n %include droid-configs-device/droid-configs.inc\n</code></pre>"},{"location":"factory/#flashing-lvm-enabled-image","title":"Flashing LVM-enabled image","text":"<p>Rebuild configs via <code>rpm/dhd/helpers/build_packages.sh --droid-configs</code>, add LVM tools to PLATFORM_SDK <code>sudo zypper in lvm2 atruncate</code>, and lastly rebuild the whole image (refer to Creating the Sailfish OS Root Filesystem), but use <code>loop</code> instead of <code>fs</code> within <code>mic create</code> as well as drop the <code>--pack-to</code> parameter.</p> <p>You may also want to change <code>EXTRA_NAME</code> to preserve the non-LVM version, yet to ever go back to that you'd need to format userdata partition as <code>ext3</code> or <code>ext4</code>.</p> <p><code>mic</code> will produce a tarball and place extracting-README.txt next to it, simply follow instructions how to flash to your device.</p>"},{"location":"factory/#enable-sailfish-os-recovery-mode","title":"Enable Sailfish OS recovery mode","text":"<p>Our recovery mode is already provided by the <code>droid-hal-$DEVICE-img-boot</code> (see section Package an LVM-enabled bootloader), and flashed to device together with the LVM image.</p> <p>To enter recovery on Nexus 5, press Volume Down and Power buttons simultaneously, this enter fastboot mode (bootloader). Using Volume Up/Down buttons select <code>Recovery mode</code> and press Power key to enter it.</p> <p>Follow instructions on screen to <code>telnet</code> and perform desired actions.</p>"},{"location":"factory/#enable-factory-reset-support","title":"Enable factory reset support","text":"<p>Whilst packaging up LVM images, we'll also place <code>root.img</code> and <code>home.img</code> to <code>system</code> partition, since we are packaging <code>/system</code> ourselves.</p> <p>Within <code>$ANDROID_ROOT/hybris/droid-configs</code> patch the following files:</p> <pre><code>diff --git a/kickstart/part/$DEVICE b/kickstart/part/$DEVICE\n part / --fstype=\"ext4\" --size=1800 --label=root\n part /home --fstype=\"ext4\" --size=800 --label=home\n+part /fimage --fstype=\"ext4\" --size=10 --label=fimage\n\ndiff --git a/kickstart/pack/$DEVICE/hybris b/kickstart/pack/$DEVICE/hybris\n /usr/sbin/vgchange -a n sailfish\n-rm home.img root.img\n+# Temporary dir for making factory image backups.\n+FIMAGE_TEMP=$(mktemp -d -p $(pwd))\n+\n+# For some reason loop files created by imager don't shrink properly when\n+# running resize2fs -M on them. Hence manually growing the loop file here\n+# to make the shrinking work once we have the image populated.\n+dd if=/dev/zero bs=1 seek=1400000000 count=1 of=fimage.img\n+/sbin/e2fsck -f -y fimage.img\n+/sbin/resize2fs -f fimage.img\n+\n+pigz -7 root.img\n+md5sum -b root.img.gz &gt; root.img.gz.md5\n+\n+pigz -7 home.img\n+md5sum -b home.img.gz &gt; home.img.gz.md5\n+\n+mount -o loop fimage.img $FIMAGE_TEMP\n+mkdir -p $FIMAGE_TEMP/${RELEASENAME}\n+mv root.img.gz* $FIMAGE_TEMP/${RELEASENAME}\n+mv home.img.gz* $FIMAGE_TEMP/${RELEASENAME}\n+umount $FIMAGE_TEMP\n+rmdir $FIMAGE_TEMP\n+\n+/sbin/e2fsck -f -y fimage.img\n+/sbin/resize2fs -f -M fimage.img\n+\n /sbin/losetup -d $LVM_LOOP\n\ndiff --git a/sparse/boot/flash.sh b/sparse/boot/flash.sh\n   $FLASHCMD userdata $x\n done\n\n+# Flashing fimage to system partition\n+for x in fimage.img*; do\n+  $FLASHCMD system $x\n+done\n+\n</code></pre> <p>Repeat the flashing process as outlined in  flashing instructions, boot the device, go to <code>Settings | Reset device</code>, and perform reset.</p> <p>Device will reboot into recovery and you will see the spinner image with status.</p> <p>Afterwards device will power off (unless you ticked <code>Reboot after reset</code> earlier), power it back on and it will boot as new.</p>"},{"location":"flashing/","title":"Flashing the rootfs image","text":"<p>In order to be able to use Sailfish OS on the device, the parts that we built and assembled in the previous chapters now need to be flashed to the device. After flashing, Sailfish OS should boot on your device on the next reboot.</p>"},{"location":"flashing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Android Recovery flashed to your device</li> <li>The stock firmware image (for your version and device)</li> <li>The Android base release (for your version and device)</li> <li>A Sailfish OS rootfs update .zip, created by <code>mic</code></li> </ul>"},{"location":"flashing/#flashing-back-to-stock-android","title":"Flashing back to Stock Android","text":"<p>It is important that you start with a fresh stock image that matches the Android base release version you are going to flash (which in turn is dictated by the Sailfish OS image you are going to flash).</p> <p>While the Android base (e.g. CyanogenMod) .zip contains all files in <code>/system/</code> (e.g. libraries and libhardware modules), the stock image also contains firmware parts and flashables for partitions that are not included in the Android base .zip.</p> <p>For example, if you are running stock 4.4.2 on a Nexus 4 (mako), and you are going to flash CM 10.1.3 and Sailfish OS to it, you have to first flash the stock 4.2.2 (note that this is 4.2, not 4.4) first, so that the firmware bits are matching the CM version.</p> <p>If you do not flash the right stock version (and therefore firmware), there might be some issues when booting into Sailfish OS:</p> <ul> <li>Problems accessing <code>/sdcard/</code> in recovery (e.g. <code>adb push</code> does not work)</li> <li>WLAN, sensors, audio and other hardware not working</li> </ul> <p>If you experience such issues, please make sure you first flash the stock system, ROM, followed by the Android base image, and finally the Sailfish OS update. Please also note that you can't just take the latest stock ROM and/or Android base ROM - both versions have to match the Android version against which the Sailfish OS adaptation was built.</p>"},{"location":"flashing/#flashing-using-android-recovery","title":"Flashing using Android Recovery","text":"<ol> <li>Boot into Android Recovery</li> <li>Upload the CM release: <code>adb push cm-10.1.3-$DEVICE.zip /sdcard/</code></li> <li>Upload Sailfish OS:    <code>adb push sailfishos-$DEVICE-devel-1.2.3.4.zip /sdcard/</code></li> <li>In the Recovery on the device:<ol> <li>Clear data and cache (factory reset)</li> <li>Install the CM release by picking the CM image</li> <li>Install Sailfish OS by picking the SFOS image</li> <li>Reboot the device</li> </ol> </li> </ol>"},{"location":"getting-in/","title":"Getting In","text":""},{"location":"getting-in/#boot-and-flashing-process","title":"Boot and Flashing Process","text":"<p>This varies from device to device. There are a few different boot loaders and flashing mechanisms used for Android devices:</p> <ul> <li>fastboot: Used by most Nexus devices</li> <li>odin: Used by most Samsung devices</li> </ul> <p>For flashing fastboot-based devices, use <code>fastboot</code> (available in the Platform SDK), for odin-based devices, use Heimdall.</p>"},{"location":"getting-in/#operating-blind-on-an-existing-device","title":"Operating Blind on an Existing Device","text":"<p>Long story short, you will have to assume that you cannot:</p> <ul> <li>See any framebuffer console</li> <li>See any error messages of any kind during bootup</li> <li>Get any information relayed from your startup process</li> <li>Set any kind of modified kernel command lines</li> </ul> <p>Hence, we have to learn how to operate blind on a device. The good news is that when you have a working kernel, you can combine it with a init ramdisk and that Android's USB gadget is built in to most kernel configurations. It is possible then for the ramdisk to set up working USB networking on most devices and then open up a telnet daemon.</p> <p>The hybris-boot repository contains such an initrd with convenient USB networking, DHCP and telnet server, plus the ability to boot into a Sailfish OS system. The init system in the hybris-boot initrd will attempt to write information via the USB device serial number and model. So <code>dmesg</code> on the host could produce:</p> HOST<pre><code>dmesg    # sample output:\n...\n[1094634.238136] usb 2-2: Manufacturer: Mer Boat Loader\n[1094634.238143] usb 2-2: SerialNumber: Mer Debug setting up (DONE_SWITCH=no)\n...\n</code></pre> <p>However <code>dmesg</code> doesn\\'t report all changes in the USB subsystem and the init script will attempt to update the iSerial field with information so also do:</p> HOST<pre><code>lsusb -v | grep iSerial   # sample output:\n iSerial    3 Mer Debug telnet on port 23 on rndis0 192.168.2.15 - also running udhcpd\n</code></pre> <p>However, if it says something like: <pre><code>[1094634.238143] usb 2-2: SerialNumber: Mer Debug setting up (DONE_SWITCH=yes)\n</code></pre> connectivity will be available via <code>telnet 192.168.2.15 2323</code> port.</p>"},{"location":"getting-in/#logs-across-reboots","title":"Logs across reboots","text":"DEVICE<pre><code>devel-su\n# change Storage=volatile --&gt; Storage=automatic in:\nvi /etc/systemd/journald.conf\nmkdir /var/log/journal\nreboot\n</code></pre> <p>Systemd suppresses journal, and some valuable info might get hidden. To prevent this, set <code>RateLimitInterval=0</code></p>"},{"location":"getting-in/#bootloops","title":"Bootloops","text":"<p>If device bootloops, there might be several reasons:</p> <ul> <li> <p>If it immediately reboots (and especially if it later boots to recovery mode),   SELinux is enabled, and all ports based on Android 4.4 (hybris-11.0) up to   Android 9.0 (hybris-16.0) need to disable it.   Add <code>CONFIG_SECURITY_SELINUX_BOOTPARAM=y</code> to your kernel defconfig, and   <code>selinux=0</code> to your kernel command line (usually in <code>BOARD_KERNEL_CMDLINE</code>   under <code>$ANDROID_ROOT/device/$VENDOR/*/BoardConfig*.mk</code>)</p> </li> <li> <p>If it reboots after a minute or so, be quick and telnet into device, then do:   <pre><code>ln -s /dev/null /etc/systemd/system/ofono.service\n</code></pre></p> </li> <li> <p>Check if your /system is mounted by systemd (system.mount unit)</p> </li> </ul>"},{"location":"getting-in/#tips","title":"Tips","text":"<p>To ease debugging in unstable/halting/logs spamming early ports:</p> DEVICE<pre><code>systemctl mask droid-hal-init\nsystemctl mask user@100000\n</code></pre>"},{"location":"getting-in/#get-connected","title":"Get connected","text":"<p>Use USB networking to connect to the Internet from your Sailfish OS</p> <p>Execute on your host as root. Use the interface which your host uses to connect to the Internet. It's wlan0 in this example:</p> HOST<pre><code>iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE\necho 1 &gt; /proc/sys/net/ipv4/ip_forward\n</code></pre> <p>Execute on the device:</p> DEVICE<pre><code>route add default gw 192.168.2.X # &lt;- host's usb0 IP\necho 'nameserver 208.67.222.222' &gt; /etc/resolv.conf\n</code></pre>"},{"location":"getting-in/#splitting-and-re-assembling-boot-images","title":"Splitting and Re-Assembling Boot Images","text":"<p>A boot.img file is basically a combination of a Linux kernel and an initramfs as <code>cpio</code> archive. The Platform SDK offer the <code>mkbootimg</code> to build a boot image from a kernel and cpio archive. To split a boot image, use <code>split_bootimg</code> in Platform SDK.</p> <p>In the Sailfish OS port, a boot image with Sailfish OS-specific scripts will be built automatically. These boot images are then available as hybris-boot.img (for booting into Sailfish OS) and hybris-recovery.img (for debugging via telnet and test-booting).</p>"},{"location":"ha-checklist/","title":"Hardware Adaptation Checklist","text":"<p>Before publishing the adaptation, at least the following features should be checked.</p> <ul> <li> <p>Thermal sensor configuration for dsme</p> <ul> <li>Even if we do not enforce any limits, CSD<sup>1</sup> gets temperature   info from dsme</li> <li>Quick test:   <pre><code>dbus-send --system --print-reply --dest=com.nokia.thermalmanager \\\n   /com/nokia/thermalmanager com.nokia.thermalmanager.battery_temperature\n</code></pre></li> </ul> </li> <li> <p>memnotify patch to kernel + config for mce</p> <ul> <li>Memory pressure normalcritical affects for example browser</li> <li>Quick test:   <pre><code>ls /etc/mce/*memnot*\n</code></pre></li> </ul> </li> <li> <p>Watchdog driver in kernel + verify it works with dsme</p> <ul> <li>We want the device to reboot if userspace gets hopelessly stuck</li> <li>Some android kernels use hardware watchdog for kernel stuck detection</li> <li>Quick test:   <pre><code>journalctl -b | grep 'dsme.*watchdog'\n</code></pre></li> </ul> </li> <li> <p>usb-moded works</p> <ul> <li>Detects charger and PC correctly</li> </ul> </li> <li> <p>USB diag mode works (optional)</p> <ul> <li>Only needed for factory releases, and not even always for those</li> </ul> </li> <li> <p>USB gadget driver in kernel + verify it works with buteo-mtp</p> <ul> <li>Android has some MTP logic imlemented at kernel and thus some   FFS stuff we need is typically missing</li> </ul> </li> <li> <p>ssu config files</p> <ul> <li>Verify ssu &amp; ssu-sysinfo agree on results</li> </ul> </li> <li> <p>Vibra driver in kernel</p> <ul> <li>Patterns choose android vibra, LED vibra or ff-memless   (memoryless force-feedback devices)</li> <li>ff-memless needs adding kernel driver</li> </ul> </li> <li> <p>Suspend works</p> <ul> <li>If the device does not suspend, standby time will drop considerably</li> <li>There is a CSD test for this (Hardware tests-&gt;All tests-&gt;System state)</li> </ul> </li> <li> <p>Resume via iphb works</p> <ul> <li>Only \"official\" way we have for scheduled wakeups from suspend</li> </ul> </li> <li> <p>Volume key probing &amp; policy works</p> <ul> <li>Display off -&gt; no ringing volume change should happen</li> <li>Display off -&gt; audio playback volume should change</li> <li>Both vol keys down -&gt; UI snapshot should happen</li> </ul> </li> <li> <p>Power key works</p> <ul> <li>Long press power key menu</li> <li>Double presses</li> <li>Loooong press shutdown in dsme</li> <li>False double press reporting from a single press</li> </ul> </li> <li> <p>Proximity sensor works in suspend</p> <ul> <li>We have built in assumption of having up-to-date p-sensor state</li> <li>NB: If device does not have PS -&gt; that must be configured</li> </ul> </li> <li> <p>Ambient light sensor works</p> <ul> <li>Long sensor power up time -&gt; can break display power on brightness</li> <li>Kernel side filtering / odd delta reporting -&gt; breaks auto adjustments</li> <li>Total darkness should report \"zero lux\"</li> </ul> </li> <li> <p>LED works</p> <ul> <li>Check the accuracy of colours and brightness</li> <li>Blocking at sysfs write can make mce unresponsive</li> <li>All but RGB LEDs probably require custom pattern config</li> </ul> </li> <li> <p>Proximity blanking during active call works</p> <ul> <li>Some ports have weird problems here</li> </ul> </li> <li> <p>CSD config</p> <ul> <li>HW features</li> <li>Factory test set</li> <li>Run-in test set</li> <li>Masked/blacklisted tests</li> </ul> </li> <li> <p>abootsettings etc. when applicable</p> </li> <li> <p>Double tap works</p> <ul> <li>There has been many devices where gestures are supported but   touch driver uses odd concepts</li> </ul> </li> <li> <p>zram in kernel</p> </li> <li> <p>Look out for suspicious logging during bootup / shutdown</p> <ul> <li>Faster/slower/just different -&gt; odd things can/will happen</li> </ul> </li> <li> <p>usb-moded vs Android USB stuff in /*.rc</p> <ul> <li>Device serial number is assumed to come from Android side logic</li> <li>Otherwise Android stuff should preferably not touch USB in any way</li> </ul> </li> <li> <p>Touch reporting</p> <ul> <li>Seems many Android kernels have issues around display power cycling &amp;   finger on screen</li> </ul> </li> <li> <p>Act dead mode</p> <ul> <li>What Android services are needed varies from one device to another</li> <li>Act dead alarms need to be verified too</li> </ul> </li> <li> <p>Extra filesystems enabled in kernel where possible</p> <ul> <li>BTRFS, F2FS, UDF, NFS, CIFS etc.</li> </ul> </li> </ul> <ol> <li> <p>You can start the CSD tool either via command line (<code>csd</code>) or via Settings app: Go to \"About Product\" and tap five times on the Build entry\u00a0\u21a9</p> </li> </ol>"},{"location":"manual-install/","title":"Manual Installation and Maintenance","text":"<p>This assumes you are booted into the Android base on your device, can <code>adb shell</code> to it to get a root shell and have your boot image and rootfs tarball ready.</p> <p>Some of these approaches also work in Android Recovery (there's an <code>adbd</code> running).</p>"},{"location":"manual-install/#extracting-the-rootfs-via-adb","title":"Extracting the rootfs via adb","text":"<p>Replace <code>sailfishos-devel-hammerhead.tar.bz2</code> with the name of your rootfs tarball:</p> PLATFORM SDK<pre><code>adb push sailfishos-devel-hammerhead.tar.bz2 /sdcard/\nadb shell\nsu\nmkdir -p /data/.stowaways/sailfishos\ntar --numeric-owner -xvf /sdcard/sailfishos-devel-hammerhead.tar.bz2 \\\n    -C /data/.stowaways/sailfishos\n</code></pre>"},{"location":"manual-install/#flashing-the-boot-image-via-adb","title":"Flashing the boot image via adb","text":"<p>The following example is for <code>hammerhead</code>, for other devices the output partition and filename is obviously different:</p> PLATFORM SDK<pre><code>cd $ANDROID_ROOT\nadb push out/target/product/hammerhead/hybris-boot.img /sdcard/\nadb shell\nsu\ndd if=/sdcard/hybris-boot.img of=/dev/block/mmcblk0p19\n</code></pre>"},{"location":"manual-install/#flashing-or-booting-the-boot-image-via-fastboot","title":"Flashing or booting the boot image via fastboot","text":"PLATFORM SDK<pre><code>cd $ANDROID_ROOT\n# to smoke test a boot image without flashing it:\nfastboot boot out/target/product/$DEVICE/hybris-boot.img\n# to permanently flash an image to boot partition:\nfastboot flash boot out/target/product/$DEVICE/hybris-boot.img\nadb shell\nsu\ndd if=/sdcard/hybris-boot.img of=/dev/block/mmcblk0p19\n</code></pre>"},{"location":"manual-install/#interacting-with-the-rootfs-via-adb-from-android","title":"Interacting with the rootfs via adb from Android","text":"<p>You can interact with the Sailfish OS rootfs and carry out maintenance (editing files, installing packages, etc..) when booted into an Android system. You have to have your rootfs already installed/extracted. You can use Android\\'s WLAN connectivity to connect to the Internet and download updates:</p> PLATFORM_SDK<pre><code>adb shell\nsu\nmount -o bind /dev /data/.stowaways/sailfishos/dev\nmount -o bind /proc /data/.stowaways/sailfishos/proc\nmount -o bind /sys /data/.stowaways/sailfishos/sys\nchroot /data/.stowaways/sailfishos/ /bin/su -\necho \"nameserver 8.8.8.8\" &gt;/etc/resolv.conf\n...\n</code></pre>"},{"location":"mic/","title":"Creating the Sailfish OS Root Filesystem","text":""},{"location":"mic/#additional-packages-for-hardware-adaptation","title":"Additional Packages for Hardware Adaptation","text":"<p>See middleware for a list of all middleware components (not all middleware components are used by every device adaptation). Most of them will have already been built by the <code>build_packages.sh --mw</code> script, but if you need an extra one, rebuild with <code>rpm/dhd/helpers/build_packages.sh --mw=GIT_URL</code>.</p> <p>Via the flexible system of patterns, you will be able to select only working/needed functions for your device.</p>"},{"location":"mic/#allowed-content-in-your-sailfish-os-image","title":"Allowed Content in Your Sailfish OS Image","text":"<p>The default set of packages results in a minimal and functional root filesystem.</p> <p>It is forbidden to add proprietary/commercial packages to your image, because royalty fees need to be paid or licence constraints are not allowing to redistribute them. Examples:</p> <ul> <li>jolla-xt9 (predictive text input)</li> <li>sailfish-eas (Microsoft Exchange support)</li> <li>aliendalvik (Android\u2122 App Support)</li> <li>sailfish-maps</li> <li>Any non-free audio/video codecs, etc.</li> </ul>"},{"location":"mic/#patterns","title":"Patterns","text":"<p>The selection of packages for each hardware adaptation has to be put into a pattern file, so that creating the image as well as any system updates in the future can pull in and upgrade all packages related to the hardware adaptation.</p>"},{"location":"mic/#modifying-a-pattern","title":"Modifying a pattern","text":"<p>To make an extra modification to a pattern, edit its respective file under <code>hybris/droid-configs/patterns/</code>. Take care and always use <code>git status/stash</code> commands. Once happy, commit to your GitHub home and eventually PR upstream.</p> <p>For patterns to take effect on the image, run the following:</p> PLATFORM SDK<pre><code>cd $ANDROID_ROOT\nrpm/dhd/helpers/build_packages.sh --configs\n</code></pre>"},{"location":"mic/#building-the-image-with-mic","title":"Building the Image with MIC","text":"<p>You need to choose a Sailfish OS version you want to build.</p> <p>Important</p> <p>Avoid building older releases unless you know what you\\'re doing - we do not guarantee backwards compatibility for old Sailfish OS versions! E.g., expect patterns to break as new HA packages get introduced etc.</p> <p>Ensure you pick the same release as your target was in build-env E.g., if target's <code>ssu lr</code> versions begin with <code>4.5.0.</code>, build Sailfish OS update 4.5.0.19 (check for the latest, non \"Early Access\" Sailfish OS version)</p> <p>Build a rootfs using RPM repositories and a kickstart file (NB: all errors are non-critical as long as you end up with a generated .zip image):</p> PLATFORM SDK<pre><code># Set the version of your choosing, latest is strongly preferred\n# (check with \"Sailfish OS version\" link above)\nexport RELEASE=4.5.0.19\n# EXTRA_NAME adds your custom tag. It doesn't support '.' dots in it!\nexport EXTRA_NAME=-my1\nrpm/dhd/helpers/build_packages.sh --mic\n</code></pre> <p>Once obtained the <code>.zip</code> file, sideload via your device's recovery mode, or examine other particular ways of deploying to your device.</p> <p>Jolla Store functionality can be enabled only if your device identifies itself uniquely - either via IMEI or (for non-cellular devices) WLAN/BT MAC address. Consult us on #sailfishos-porters IRC channel on oftc.net about details.</p> <p>If creation fails due to absence of a package required by pattern, note down the package name.</p> <p>If that package is critical (e.g. <code>libhybris</code>, <code>qt5-qpa-hwcomposer-plugin</code> etc.), build and add it to the local repo as explained in additional packages section. Afterwards perform:</p> <ul> <li>Modifying a pattern</li> <li>Building the image with MIC</li> </ul> <p>Otherwise if a package is not critical, and you accept to have less functionality (or even unbootable) image, you can temporarily comment it out from patterns in <code>hybris/droid-configs/patterns</code> and orderly perform:</p> <ul> <li>Modifying a pattern</li> <li>Building the image with MIC</li> </ul> <p>Alternatively (or if you can't find it among patterns) provide a line beginning with dash (e.g. <code>-jolla-camera</code>) indicating explicit removal of package, to your .ks <code>%packages</code> section (remember that regenerating .ks will overwrite this modification).</p>"},{"location":"mic/#troubleshooting","title":"Troubleshooting","text":""},{"location":"mic/#devnull-permission-denied-while-using-mic","title":"/dev/null - Permission denied (while using <code>mic</code>)","text":"<p>Most likely the partition your Platform SDK resides in, is mounted with <code>nodev</code> option. Remove that option from mount rules.</p>"},{"location":"mic/#executing-commands-in-the-build-environment","title":"Executing commands in the build environment","text":"<p>You can execute commands to build and install packages under the build environment, inspect and debug any issues. The syntax is shown in Installing Build Tools for Your Device.</p> <p>Note that <code>mb2</code> uses a working copy of your original build target, which means you can experiment with <code>mb2 build-shell</code> at will, but once you have found a desired fix, make it permanent by recording the changes in your source code (e.g. do not leave installed packages with <code>zypper in</code> lying around, but add them to your .spec's <code>BuildRequires</code>).</p> <p>If you break your build environment via <code>mb2 build-shell</code>, you can reset it back to its clean state via <code>mb2 -t $VENDOR-$DEVICE-$PORT_ARCH build-requires reset</code>. This happens implicitly after re-running <code>build_packages.sh</code><sup>1</sup>.</p> <p>Use <code>mb2 ... build-requires diff</code> if you want to know what you have done to your build environment with <code>mb2</code> in terms of installed/removed packages<sup>2</sup>.</p> <p><code>mb2 ... build-shell</code> is limited to launch only from directories where you previously ran commands like <code>mb2 ... build</code> or <code>mb2 ... build-init</code><sup>3</sup>. Such commands are run under <code>$ANDROID_ROOT</code> during the build of dhd, so you can run <code>mb2 build-shell</code> from <code>$ANDROID_ROOT</code> if you find no better place.</p> <ol> <li> <p>As long as your original build target does not change, <code>mb2</code> keeps using the same working copy (\"snapshot\" in mb2's speech) of your build target in subsequent executions, preserving any changes you make to it. When your original build target changes, <code>mb2</code> will reset the working copy to match the updated state of your original target next time it is invoked. This happens e.g. when you use <code>build_packages.sh</code>, which intentionally works directly on your original build target. Factors that are regarded as a change in the original build target are: RPM DB change, SSU configuration, and few other things.\u00a0\u21a9</p> </li> <li> <p>If you need to make permanent changes to the original build environment (not recommended), add <code>--no-snapshot=force</code> option at the beginning of <code>mb2</code> command line (it is a global option).\u00a0\u21a9</p> </li> <li> <p><code>mb2</code> looks for a directory named <code>.mb2</code>, where it stores some of its state. It is created implicitly by <code>mb2 ... build</code> and you can also create it explicitly with <code>mb2 -t $VENDOR-$DEVICE-$PORT_ARCH build-init</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"middleware/","title":"Middleware","text":"<p>This chapter contains some background information about the middleware parts that are part of the Hardware Adapation. Using this info, it should be possible to customize and build the middleware parts for a given device.</p>"},{"location":"middleware/#mce-libhybris-plugin","title":"MCE libhybris Plugin","text":"<p>Todo</p>"},{"location":"middleware/#mce-configuration","title":"MCE configuration","text":"/etc/mce/60-doubletap-jolla.ini <p>Configures the touchscreen kernel driver sysfs that can be used to disable and enable double tap to wake up feature. Example of its content:</p> <pre><code># Configuration for doubletap wakeup plugin\n[DoubleTap]\n# Path to doubletap wakeup control file\nControlPath=/sys/bus/i2c/drivers/touch_synaptics/3-0020/double_tap_enable\n# Value to write when enabling doubletap wakeups\nEnableValue=1\n# Value to write when Disabling doubletap wakeups\nDisableValue=0\n</code></pre> <p>Todo</p> <p>/etc/mce/60-mce-cpu-scaling-governor.ini</p> <p>/etc/mce/60-mce-display-blank-timeout.conf</p> <p>/etc/mce/60-mce-display-brightness.conf</p> <p>/etc/mce/60-mce-possible-display-dim-timeouts.conf</p> <p>/etc/mce/60-memnotify-jolla.conf</p>"},{"location":"middleware/#non-graphical-feedback-daemon-ngfd","title":"Non-Graphical Feedback Daemon (NGFD)","text":"<p>The Non-Graphical Feedback Daemon provides combined audio, haptic, and LED feedback for system events and alarms. These events include such things as ring tones, message tones, clock alarms, email notifications, etc.</p> <p>From here on shortened to NGFD.</p> <p>Todo</p> <p>add more detail about configuring NGFD.</p>"},{"location":"middleware/#configuring-haptics","title":"Configuring Haptics","text":"<p>Sailfish OS uses NGFD to provide haptic feedback. We use a QtFeedback plugin to bridge it with NGFD. The NGFD plugin is for providing feedback for events and alarms, it interfaces directly with QtFeedback that can be used by 3rd-party applications.</p> <p>When configuring haptics it is important to know if your device uses ffmemless or the LED/Droid based vibrator interface.</p> <p>To determine if your device uses the LED/native interface check for <code>/sys/class/timed_output/vibrator/enable</code> or <code>/sys/class/leds/vibrator/activate</code>. The exact path for these might be a little different in some cases, e.g. instead of <code>vibrator</code> the path could contain <code>foobar</code>, <code>foobar</code> being the device name in this case. Check for down below Non-Graphic Feedback Daemon Native Vibrator Plugin for more.</p> <p>If these files are not present it is very likely that your device uses ffmemless to control haptics. To verify if your device uses ffmemless install the <code>mce-tools</code> package and run <code>evdev_trace -i</code>. If the listing contains a device with the type <code>EV_FF</code>, then your device uses ffmemless.</p> <p>The qt5-feedback-haptics-ffmemless used before Sailfish OS 4.3 is deprecated in favor of the before mentioned QtFeedback plugin.</p> <p>When migrating away from qt5-feedback-haptics-ffmemless /usr/lib/qt5/plugins/feedback/ffmemless.ini can be removed without further intervention.</p> <p>You can copy the Configuration file of the specific plugin used by your device to tune it fit better to your device.</p> <p>The reason we have possibility for device specific effects is that hardware mechanics and the vibra engines differ greatly device-by-device, and single settings will not give good effect on all devices.</p> <p>Good guideline for VKB haptic is that it should be as short as possible, and vibrate at the resonance frequency of the device mechanics when vibra engine reaches top magnitude of the vibra effect. It should not feel like vibration, but like a single kick.</p>"},{"location":"middleware/#ngfd-pulseaudio-plugin","title":"NGFD PulseAudio Plugin","text":"<p>Todo</p>"},{"location":"middleware/#ngfd-ffmemless-plugin","title":"NGFD ffmemless Plugin","text":"<p>This is the main plugin handling vibra feedback for Sailfish OS for devices that use the ffmemless interface.</p> <p>The default configuration file can be found in /usr/share/ngfd/plugins.d/50-ffmemless.ini.</p> <p>The default configuration files can be over-ridden with setting environment variable <code>NGF_FFMEMLESS_SETTINGS</code>.</p> <p>To set the environment variables add environment config file to your config package that installs to <code>/var/lib/environment/nemo/60-&lt;device&gt;-vibra.conf</code>. Replace with your <code>&lt;device&gt;</code> with the name of your device. E.g. mako, hammerhead etc.</p> <p>And that file should look like below:</p> <pre><code>NGF_FFMEMLESS_SETTINGS=/usr/share/ngfd/plugins.d/ngf-vibra-&lt;device&gt;.ini\n</code></pre> <p>Now you can use the file to tune force feedback effects suitable specifically for your device. For template to start making your own configuration files, just copy-paste the ngfd 50-ffmemless.ini default config files as the device specific files and then edit only needed bits.</p> <p>An alternative instead of using the environment variable is duplicating the <code>50-ffmemless.ini</code> in the same folder with a different name such as <code>51-ffmemless.ini</code>, NGFD will now pickup your configuration file instead of the stock configuration file.</p> <p>This especially affects those devices using ffmemless CUSTOM vibration patterns, read the default 50-ffmemless.ini. To check if the device uses ffmemless custom vibration patterns check if <code>evdev_trace</code> contains a device that contains <code>FF_CUSTOM</code></p>"},{"location":"middleware/#non-graphic-feedback-daemon-native-vibrator-plugin","title":"Non-Graphic Feedback Daemon Native Vibrator Plugin","text":"<p>This plugin uses the native kernel interface from the timed output driver or the led vibrator interface. The native plugin doesn't require any configuration normally.</p> <p>It is possible to set the path of the activation and duration controls as shown below if the plugin can't find these on its own:</p> <pre><code>[droid-vibrator]\nnative.path          = /sys/class/leds/&lt;device&gt;/duration\nnative.activate_path = /sys/class/leds/&lt;device&gt;/activate\n</code></pre> <p>Replace <code>&lt;device&gt;</code> with the name of device directory for your vibration device.</p> <p>It is the preferred method if the ffmemless plugin isn\\'t used.</p>"},{"location":"middleware/#ngfd-droid-vibrator-plugin","title":"NGFD Droid Vibrator Plugin","text":"<p>This is a secondary vibra plugin for demoing and quick ports. It works out of the box with android timed output drivers. The feature set is reduced compared to ffmemless plugin.</p> <p>Todo</p>"},{"location":"middleware/#pulseaudio-droid-modules","title":"PulseAudio Droid Modules","text":"<p>Todo</p> <p>more information about how PA works</p>"},{"location":"middleware/#qt5-hardware-composer-qpa","title":"Qt5 Hardware Composer QPA","text":"<p>This Qt Platform Abstraction plugin makes use of the libhardware hwcomposer API to send rendered frames from the Wayland Compositor to the actual framebuffer. While for some older devices, just flipping the fbdev was enough, more recent devices actually require using hwcomposer to request flipping and for vsync integration.</p> <p>The important environment variables are:</p> <code>EGL_PLATFORM</code> For the Wayland Compositor, this needs to be set to <code>fbdev</code> on devices with older hwcomposer versions, and to <code>hwcomposer</code> for hwcomposer version 1.1 and newer. For best results, first try <code>fbdev</code>, and if it doesn't work, try <code>hwcomposer</code> instead. For the Wayland Clients, this always needs to be set to <code>wayland</code>. <code>QT_QPA_PLATFORM</code> For the Wayland Compositor, this needs to be set to <code>hwcomposer</code> to use the plugin. Previously, <code>eglfs</code> was used, but the <code>hwcomposer</code> module replaces the old plugin on Sailfish OS on Droid. For Wayland Clients, this always needs to be set to <code>wayland</code>. <p>When starting up an application (e.g. the Wayland Compositor, <code>lipstick</code>), the systemd journal (<code>journalctl -fa</code> as user root) will show some details about the detected screen metrics, which will come from the framebuffer device:</p> <pre><code>HwComposerScreenInfo:251 - EGLFS: Screen Info\nHwComposerScreenInfo:252 -  - Physical size: QSizeF(57, 100)\nHwComposerScreenInfo:253 -  - Screen size: QSize(540, 960)\nHwComposerScreenInfo:254 -  - Screen depth: 32\n</code></pre> <p>Also, it will print information about the hwcomposer module and the device. In this specific case, the hwcomposer version is 0.3:</p> <pre><code>== hwcomposer module ==\n* Address: 0x40132000\n* Module API Version: 2\n* HAL API Version: 0\n* Identifier: hwcomposer\n* Name: Qualcomm Hardware Composer Module\n* Author: CodeAurora Forum\n== hwcomposer module ==\n== hwcomposer device ==\n* Version: 3 (interpreted as 30001)\n* Module: 0x40132000\n== hwcomposer device ==\n</code></pre> <p>The source tree contains different implementations of hwcomposer backends, each one for a different hwcomposer API version (see <code>hwcomposer/hwcomposer_backend.cpp</code>). Based on that detection, one of the existing implementations is used. Right now, the following implementations exist:</p> hwcomposer_backend_v0 Version 0.x (e.g. 0.3) of the hwcomposer API. It can handle swapping of an EGL surface to the display, doesn't use any additional hardware layers at the moment and can support switching the screen off. The VSync period is queried from the hwcomposer device, but it will fall back to 60 Hz if the information cannot be determined via the libhardware APIs. (<code>EGL_PLATFORM=fbdev</code>) hwcomposer_backend_v10 Version 1.0 of the hwcomposer API. It supports one display device, handles VSync explicitly and uses a single hardware layer that will be drawn via EGL (and not composed via hwcomposer). Swapping is done by waiting for VSync and uses libsync-based synchronization of posting buffers. Switching the screen off is also supported, and sleeping the screen disables VSync events. Also, the same VSync period algorithm is used (try to query from libhardware, fall back to 60 Hz if detection fails). (<code>EGL_PLATFORM=fbdev</code>) hwcomposer_backend_v11 Version 1.1, 1.2, 1.3, 1.4, and 1.5 of the hwcomposer API. Versions higher or equal than 1.3 only support physical displays, whereas 1.1 and 1.2 support also virtual displays. This requires libsync and hwcomposer-egl from libhybris. Most of the hwcomposer 1.0 API properties apply, with the exception that frame posting and synchronization happens with the help of libhybris' hwcomposer EGL platform. (<code>EGL_PLATFORM=hwcomposer</code>) <p>Instead of running the Wayland Compositor (lipstick) on top of the hwcomposer QPA plugin, one can also run all other Qt 5-based applications, but the application can only open a single window (multiple windows are not supported, and will cause an application abort). For multiple windows, Wayland is used. This means that for testing, it is possible to run a simple, single-window Qt 5 application on the framebuffer (without any Wayland Compositor in between) by setting the environment variables <code>EGL_PLATFORM</code> and <code>QT_QPA_PLATFORM</code> according to the above.</p>"},{"location":"middleware/#sensorfw-qt-5-libhybris-plugin","title":"SensorFW Qt 5 / libhybris Plugin","text":"<p>Todo</p>"},{"location":"middleware/#build-ha-middleware-packages","title":"Build HA Middleware Packages","text":"<p><code>rpm/dhd/helpers/build_packages.sh</code> now is taking care of builds/rebuilds/local repo preparation and patterns.</p>"},{"location":"middleware/#all-other-packages","title":"All other packages","text":"<p>Please compile any other required packages should a build/mic process indicate a dependency on them. Feel free to add/remove those packages to/from patterns to suit your port\\'s needs.</p> <p>Follow the exact same compilation approach as with above packages. Known packages are:</p> <ul> <li>https://github.com/mer-hybris/unblank-restart-sensors - needed only by mako</li> </ul>"},{"location":"modifications/","title":"Modifications and Patches","text":"<p>Running Sailfish OS on top of a Mer Hybris adaptation requires a few modifications to the underlying Android base. We maintain forks of some repos with those patches applied.</p>"},{"location":"modifications/#hybris-modifications-to-an-android-base","title":"Hybris Modifications to an Android base","text":"<p>Our modifications are tracked by our own Hybris-specific repo manifest file. The below sections outline our modifications to these sources.</p>"},{"location":"modifications/#droid-system","title":"Droid System","text":"<p>In order to work with <code>libhybris</code>, some parts of the lower levels of Android need to be modified:</p> bionic/ <ul> <li>Pass <code>errno</code> from bionic to libhybris (<code>libdsyscalls.so</code>)</li> <li>Rename <code>/dev/log/</code> to <code>/dev/alog/</code></li> <li>TLS slots need to be re-assigned to not conflict with glibc</li> <li>Support for <code>HYBRIS_LD_LIBRARY_PATH</code> in the linker</li> <li>Add <code>/usr/libexec/droid-hybris/system/lib</code> to the linker search path</li> </ul> external/busybox/ <ul> <li>Busybox is used in the normal and recovery boot images. We need   some additional features like <code>mdev</code> and <code>udhcpd</code></li> </ul> system/core/ <ul> <li>Make <code>cutils</code> and <code>logcat</code> aware of the new log location (<code>/dev/alog/</code>)</li> <li>Add <code>/usr/libexec/droid-hybris/lib-dev-alog/</code> to the <code>LD_LIBRARY_PATH</code></li> <li>Force SELinux OFF since hybris does not utilise the relevant Android   parts, and leaving SELinux support ON would then cause device to reboot   to recovery</li> <li>Remove various <code>init</code> and <code>init.rc</code> settings and operations that are   handled by <code>systemd</code> and/or Hybris on a Sailfish OS system</li> </ul> frameworks/base/ <ul> <li>Only build <code>servicemanager</code>, <code>bootanimation</code> and <code>androidfw</code> to make   the minimal Droid HAL build smaller (no Java content)</li> </ul> libcore/ <ul> <li>Don't include <code>JavaLibrary.mk</code>, as Java won't be available</li> </ul> <p>All these modifications have already been done in the mer-hybris GitHub organisation of forks from various Android sources. If its <code>android</code> manifest is used, these patches will be included automatically.</p> <p>In addition to these generic modifications, for some devices and SoCs we also maintain a set of patches to fix issues with drivers that only happen in Sailfish OS, for example:</p> <ul> <li>hardware/samsung/: SEC hwcomposer: Avoid segfault if <code>registerProcs</code> was   never called</li> </ul>"},{"location":"modifications/#kernel","title":"Kernel","text":"<p>For the Kernel, some configuration options must be enabled to support <code>systemd</code> features, and some configuration options must be disabled, because they conflict or block certain features of Sailfish OS.</p> <p>Required Configuration Options</p> <p>See <code>$ANDROID_ROOT/hybris/hybris-boot/init-script</code> function <code>check_kernel_config()</code> for a list of required kernel options.</p> <p>Conflicting Configuration Options</p> <code>CONFIG_ANDROID_PARANOID_NETWORK</code> This would make all network connections fail if the user is not in the group with ID 3003. <p>As an alternative to checking the kernel options in the initramfs, the script <code>$ANDROID_ROOT/hybris/mer-kernel-check</code> can also be used to verify if all required configuration options have been enabled.</p>"},{"location":"modifications/#configuring-and-compiling-the-kernel","title":"Configuring and Compiling the Kernel","text":"<p>For supported devices, the kernel is built as part of <code>mka hybris-hal</code> with the right configuration.</p> <p>For new devices, you have to make sure to get the right kernel configuration included in the repository. For this, clone the kernel repository for the device into mer-hybris and configure the kernel using <code>hybris/mer-kernel-check</code>.</p>"},{"location":"naming/","title":"Package Naming Policy","text":"<p>For consistency, certain hardware adaptation / middleware plugin packages have to be named after a certain pattern.</p> <p>As in the other chapters of this guide, <code>$DEVICE</code> should be replaced with the device codename (e.g. <code>mako</code> for Nexus 4), and the asterisk (*) is used as wildcard / placeholder.</p>"},{"location":"naming/#list-of-naming-rules","title":"List of naming rules","text":"<p>Packages that are arch-specific (e.g. <code>aarch64</code>), device-specific and contain <code>$DEVICE</code> in their name:</p> <ul> <li>The arch-specific HAL RPMs (built from <code>droid-hal-device</code>) should be   named droid-hal-$DEVICE, e.g.:<ul> <li><code>droid-hal-mako</code>,</li> <li><code>droid-hal-mako-devel</code>,</li> <li><code>droid-hal-mako-img-boot</code>,</li> <li><code>droid-hal-mako-kernel</code>,</li> <li><code>droid-hal-mako-kernel-modules</code>,</li> <li><code>droid-hal-mako-kickstart-configuration</code>,</li> <li><code>droid-hal-mako-patterns</code>,</li> <li><code>droid-hal-mako-policy-settings</code></li> <li><code>droid-hal-mako-pulseaudio-settings</code></li> </ul> </li> <li>The package containing kickstart files for <code>mic</code> should be named   ssu-kickstarts-$DEVICE, e.g.<ul> <li><code>ssu-kickstarts-mako</code></li> </ul> </li> </ul> <p>Package that are arch-independent (<code>noarch</code>), device-specific and contain <code>$DEVICE</code> in their name:</p> <ul> <li>The arch-independent HAL RPMs (built from <code>droid-hal-device</code>) should   be named: droid-hal-$DEVICE-*, e.g.:<ul> <li><code>droid-hal-mako-img-recovery</code></li> <li><code>droid-hal-mako-sailfish-config</code></li> </ul> </li> <li>The SensorFW libhybris plugin configuration should be named   hybris-libsensorfw-qt5-configs</li> </ul> <p>Packages that are arch-specific (e.g. <code>aarch64</code>), device-specific, but do not contain <code>$DEVICE</code>:</p> <ul> <li>RPMs built from libhybris should be named libhybris-*<ul> <li><code>libhybris-libEGL</code>)</li> </ul> </li> <li>Plugins for the non-graphic feedback daemon should be named ngfd-plugin-*<ul> <li><code>ngfd-plugin-droid-vibrator</code>)</li> <li>as well as their Qt plugin qt5-feedback-haptics-droid-vibrator</li> </ul> </li> <li>The QPA hwcomposer plugin should be named qt5-qpa-hwcomposer-plugin</li> <li>The PulseAudio support modules should be named pulseaudio-modules-droid</li> <li>The GStreamer plugins should be named libgstreamer0.10-* and/or   gstramer0.10-*, e.g.:<ul> <li><code>libgstreamer0.10-gralloc</code></li> <li><code>libgstreamer0.10-nativebuffer</code></li> <li><code>gstreamer0.10-omx</code>,</li> <li><code>gstreamer0.10-droideglsink</code></li> <li><code>gstreamer0.10-droidcamsrc</code></li> </ul> </li> <li>The SensorFW libhybris plugin should be named hybris-libsensorfw-qt5</li> </ul>"},{"location":"naming/#list-of-provides","title":"List of Provides","text":"<ul> <li>droid-hal-$DEVICE-* provides droid-hal-*, e.g.:<ul> <li><code>droid-hal-$DEVICE-pulseaudio-settings</code> provides <code>droid-hal-pulseaudio-settings</code></li> </ul> </li> </ul> <p>Todo</p> <p>The above \"rules\" are the current state of our hardware adaptation. Here are some things that should be improved there:</p> <ul> <li>Some arch-specific packages contain arch-independent config files or   binary blobs - make them arch-independent (<code>noarch</code>) instead</li> <li>Unify the GStreamer plugin naming (either libgstreamer0.10-* or     gstreamer0.10-*) to not have two naming schemes there</li> <li>The PulseAudio settings package usually is called pulseaudio-settings-$DEVICE   (we currently have droid-hal-$DEVICE-pulseaudio-settings, maybe this can be   implemented as a <code>Provides:</code>?)</li> <li>The Linux kernel modules are in droid-hal-$DEVICE-kernel-modules at   the moment, in other hardware adaptations we use kmod-xyz-$DEVICE</li> <li>The recovery partition in the image at the moment is   droid-hal-$DEVICE-img-recovery, but for other hardware   adaptations we use jolla-recovery-$DEVICE</li> </ul>"},{"location":"obs/","title":"Obs","text":"<p>Not publishing this atm</p>"},{"location":"obs/#uploading-droid-hal-device-to-obs","title":"Uploading <code>droid-hal-device</code> to OBS","text":"<p>For now, we upload the locally-built <code>droid-hal-device</code> packages to OBS as binary packages:</p> <pre><code>PLATFORM_SDK $\n\ncd $ANDROID_ROOT/rpm/obs-upload\nmake\n</code></pre>"},{"location":"obs/#packaging-and-building-libhybris-in-obs","title":"Packaging and Building <code>libhybris</code> in OBS","text":""},{"location":"obs/#packaging-and-building-qt5-qpa-hwcomposer-plugin-in-obs","title":"Packaging and Building <code>qt5-qpa-hwcomposer-plugin</code> in OBS","text":""},{"location":"ota-updates/","title":"OTA (Over-the-Air) Updates","text":"<p>You can setup to upgrade a Sailfish OS device over the air, a.k.a. OTA update.</p>"},{"location":"ota-updates/#prepare-the-infrastructure","title":"Prepare the infrastructure","text":"<ul> <li>Ensure your Sailfish OS version is at least 3.2.1 (3.4.0 for <code>aarch64</code>)</li> <li>Create file <code>20-mydomain.ini</code> (rename \"mydomain\" as you see fit)   under <code>$ANDROID_ROOT/hybris/droid-configs/sparse/usr/share/ssu/repos.d/</code>   with the following content:</li> </ul> <pre><code>[release]\nadaptation=https://mydomain.net/%(release)/%(vendor)-%(adaptation)/%(arch)/\n</code></pre> <ul> <li>Substitute <code>https://mydomain.net/</code> with your Web server address   (including subpath if exists)</li> <li>The <code>%(release)/%(vendor)-%(adaptation)/%(arch)/</code> format is advised,   because it's the most future-proof. E.g. for the Nexus 5 this   string would resolve to <code>4.5.0.19/lge-hammerhead/aarch64/</code></li> <li>Commit the above change to droid-configs (including updating the   submodule, which introduces timestamped versioning, so updates get   picked up)</li> <li>Make new image and ensure devices are flashed which will be   receiving future updates</li> <li>Make some changes to your adaptation (e.g. fix some HW issue) and   rebuild the affected part via <code>build_packages.sh</code>, so that version   numbers increase</li> </ul>"},{"location":"ota-updates/#test-for-any-breakages","title":"Test for any breakages","text":"<p>Before deploying any updates to production, they must be tested first.</p> <p>Prerequisites:</p> <ul> <li>Web server (e.g. Apache) running on HOST and accessible within network</li> <li>Directory listing doesn't need to be enabled</li> <li>Assuming Web server's rootdir is <code>/srv/http</code></li> </ul> <p>Perform the following:</p> HOST<pre><code>. ~/.hadk.env\nrm -rf /srv/http/sailfish-tmp-test-repo\ncp -ar $ANDROID_ROOT/droid-local-repo/$DEVICE /srv/http/sailfish-tmp-test-repo\nrm -rf /srv/http/sailfish-tmp-test-repo/repo\ncreaterepo_c /srv/http/sailfish-tmp-test-repo\n</code></pre> <p>SSH into your device and execute (substituting <code>https://mydomain.net</code> with the address to your Web server):</p> DEVICE<pre><code>ssu ar sfos-test https://mydomain.net/sailfish-tmp-test-repo\ndevel-su -p pkcon install zypper\ndevel-su zypper refresh sfos-test\ndevel-su zypper dup --from sfos-test\n</code></pre> <p>Check that all the packages you touched are to be updated or removed as expected. Afterwards you can press \"Yes\" to execute the update and check if the device functions as desired, also after reboot.</p> <p>Once happy, clean up the testing environment:</p> DEVICE<pre><code>ssu rr sfos-test\n</code></pre> HOST<pre><code>rm -rf /srv/http/sailfish-tmp-test-repo\n</code></pre>"},{"location":"ota-updates/#release-into-production-for-all-users","title":"Release into production for all users","text":"<p>Once successfully tested, deploy the stable packages to the release repo:</p> HOST<pre><code>. ~/.hadk.env\nrm -rf /srv/http/$RELEASE/$VENDOR-$DEVICE/$PORT_ARCH\nmkdir -p /srv/http/$RELEASE/$VENDOR-$DEVICE\ncp -ar $ANDROID_ROOT/droid-local-repo/$DEVICE \\\n       /srv/http/$RELEASE/$VENDOR-$DEVICE/$PORT_ARCH\nrm -rf /srv/http/$RELEASE/$VENDOR-$DEVICE/$PORT_ARCH/repo\ncreaterepo_c /srv/http/$RELEASE/$VENDOR-$DEVICE/$PORT_ARCH\n</code></pre> <p>To receive the update, each device will have to execute <code>devel-su -p version --dup</code>, and reboot when instructed.</p>"},{"location":"ota-updates/#adding-custom-rpm-packages","title":"Adding custom RPM packages","text":"<p>You can add any other RPM binary packages to the local build repository (i.e. packages that were not created by running <code>build_packages.sh</code>). For example:</p> PLATFORM SDK<pre><code>cd $ANDROID_ROOT\n# Alternatively you can use `mb2 --output-dir ... build` instead of copying\ncp -a path/to/custom-built.rpm droid-local-repo/$DEVICE\n</code></pre> <p>To make the devices of your users pull this RPM package in, ensure some other package or pattern requires it, then test and deploy your repo as per instructions above.</p>"},{"location":"ota-updates/#updating-to-the-next-sailfish-os-release","title":"Updating to the next Sailfish OS release","text":"<p>If another official Sailfish OS update has been released since you last published your HW adaptation update, perform the following:</p> <p>Update your SDK target device build environment (see how in the last paragraph of Setup the Platform SDK).</p> <p>Alternatively, you can remove it and create a new one as per Installing Build Tools for Your Device.</p> <p>Remove or backup your local build repository:</p> PLATFORM SDK<pre><code>cd $ANDROID_ROOT\n\nPREV_RELEASE=4.4.0.68    # adjust to the previous release version you were on\n\nmv droid-local-repo/$DEVICE droid-local-repo/$DEVICE-$PREV_RELEASE\nmkdir droid-local-repo/$DEVICE\n</code></pre> <p>Then rebuild all packages and a new image by executing <code>build_packages.sh</code>.</p> <p>Afterwards test the rebuilt repo. The actual testing sequence on the device will be different:</p> DEVICE<pre><code>ssu ar sfos-test https://mydomain.net/sailfish-tmp-test-repo\nssu dr adaptation0\nssu re 4.5.0.19    # adjust to the actual version\ndevel-su -p version --dup\nssu rr sfos-test\nssu er adaptation0\n</code></pre> <p>Then reboot as and test device functionality.</p> <p>Once satisfactory, publish your repo for all users.</p> <p>Finally, to receive the update, each device will have to execute:</p> DEVICE<pre><code>ssu re 4.5.0.19    # adjust to the actual version\ndevel-su -p version --dup\n</code></pre> <p>Note</p> <p>The <code>%(release)</code> in your self-hosted repo (visible via <code>ssu lr</code>) will get updated automatically after <code>ssu re</code>.</p> <p>After <code>devel-su -p version --dup</code> has finished, reboot as instructed.</p>"},{"location":"overview/","title":"Overview","text":""},{"location":"overview/#goal","title":"Goal","text":"<p>By following this guide you can set up a Sailfish OS (or another Sailfish Core based) Linux system that will run on an Android device, on top of an existing Android Hardware Adaptation kernel and drivers.</p> <p>This consists of:</p> <ul> <li>Sailfish Core: the GNU/Linux userspace core</li> <li>Android Hardware Adaptation (HA/HAL), consisting of:<ul> <li>Device-specific Android Kernel</li> <li>Android base which can be<ul> <li>LineageOS</li> <li>AOSP - Android Open Source Project</li> <li>CAF - Code Aurora Forum</li> <li>Sony Open Devices program</li> <li>Vendor-specific Android base</li> </ul> </li> <li>Binary device drivers taken from an Android base</li> <li>Hybris patches to the Android base</li> <li>The libhybris interface built against the binary drivers</li> <li>Middleware packages depending on hardware-specific plugins</li> <li>A Qt/Wayland QPA plugin utilizing the Android <code>hwcomposer</code></li> </ul> </li> <li>Sailfish OS components</li> </ul>"},{"location":"overview/#development","title":"Development","text":""},{"location":"overview/#requirements","title":"Requirements","text":"<p>The development environment uses the Platform SDK, with:</p> <ul> <li>Build Tools consisting of cross-compilers (tooling) and an     emulated rootfs for your device architecture (target), containing     device-specific headers and libraries -- will also be referred as     build environment throughout the document</li> <li>a HA build SDK (a minimal Ubuntu chroot required to build the     Android sources)</li> </ul> <p>During the HA development you'll typically have one window/terminal using the HA build SDK where you build and work on Android code and another session using the Platform SDK where you build RPMs for the hardware adaptation.</p> <p>Setting up the Platform SDK, as well as the device-specific build environment and the Ubuntu HA build chroot is described in SDK setup.</p> <p>Commands and output from the Platform SDK session are indicated using <code>PLATFORM SDK</code> at the top of the code block, like this:</p> PLATFORM SDK<pre><code>echo \"run this command in the Platform SDK terminal\"\n</code></pre> <p>How to enter <code>PLATFORM SDK</code> is explained in the platform SDK setup.</p> <p>Commands and output from the HA build session are indicated using <code>HABUILD SDK</code> at the top of the code block, like this:</p> HABUILD SDK<pre><code>echo \"run this command in the Ubuntu HA build SDK terminal\"\n</code></pre> <p>How to enter <code>HABUILD SDK</code> is explained in the Android build environment setup.</p>"},{"location":"overview/#the-build-area-root-directory","title":"The build area root directory","text":"<p>In this guide, we refer to the SDK directory hosting Platform SDK, Build Tools, and Ubuntu chroot with the environment variable <code>$PLATFORM_SDK_ROOT</code>. You need around 10GB of space in total.</p>"},{"location":"overview/#build-components","title":"Build components","text":"<p>There are a number of components to build; the lower level and Android related components are built in the HA build SDK; the rest are built in the Platform SDK.</p> <ul> <li> <p>In the HA build SDK</p> <ul> <li>a kernel</li> <li>a hacking friendly initrd which supports various boot options</li> <li><code>hybris-boot.img</code> and <code>hybris-recovery.img</code> (for booting and debugging)</li> <li>a minimal Android <code>/system/</code> tree</li> <li>modified Android parts for compatibility with libhybris and Sailfish OS   (e.g. Bionic libc, <code>logcat</code>, <code>init</code>, ...)</li> </ul> </li> <li> <p>In the Platform SDK</p> <ul> <li>RPM packages containing all the built binaries and extracted configs</li> <li>Hardware-specific middleware and plugins (e.g. Qt QPA plugins, PulseAudio)</li> </ul> </li> </ul> <p>For distribution, RPM packages are uploaded to a HA-specific repository. With this repository, full system images using the <code>mic</code> utility. The <code>mic</code> utility is usually also run inside the Platform SDK.</p>"},{"location":"overview/#deployment","title":"Deployment","text":"<p>The <code>hybris-boot.img</code> (containing both the kernel and our custom initrd) is flashed to the device, while the Sailfish OS rootfs is placed in a subdirectory of the <code>/data/</code> partition alongside an existing, unmodified Android system.</p> <p>The Sailfish OS rootfs is then used as a switchroot target with /data bind-mounted inside it for shared access to any user data.</p>"},{"location":"preparing/","title":"Preparing Your Device","text":"<p>Verify that you can backup and restore your device and that you understand device recovery options. This is not only useful when flashing images you build with this guide, but also in case you want to reset your device to its factory state with stock Android (note that not all Android vendors provide factory images for download, so you might need to create a full backup of your running Android system and store it in a safe place before starting to erase and reflash the device with your custom builds).</p>"},{"location":"preparing/#backup-and-verify-your-device","title":"Backup and Verify Your Device","text":"<p>As mentioned above, it might be helpful to backup the existing stock Android image before flashing the Android base release for the first time, as obtaining the stock image might be hard for some vendors (e.g. some stock images are only available as self-extracting .exe package for Windows) or impossible (some vendors do not provide stock images for download).</p> <p>Use Android Recovery (e.g. TWRP or ClockworkMod) to:</p> <ol> <li>Backup to SD card: system, data, boot and recovery partitions</li> <li>Test restoring the backup (important)</li> </ol> <p>Warning</p> <p>While backing up to internal device storage is possible for some devices, if during porting you end up overwriting that partition, your backups will be gone. In that case (and in case of devices without SD card slots), it's better to also copy the backup data to your development machine (e.g. via <code>adb pull</code> in recovery). Recent versions of <code>adb</code> support full-device backups to a host computer using the <code>adb backup</code> feature.</p> <p>See the ClockworkMod Instructions for additional help.</p>"},{"location":"preparing/#flash-and-test-your-android-base-image","title":"Flash and Test your Android base image","text":"<p>Flash an image that you built or obtained of your Android base, whether it's LineageOS, CAF, AOSP, or another.</p> <p>The official LineageOS flashing instructions can be found on this LineageOS wiki page.</p> <p>You may also want to verify that the Android base build for your device is fully functional, to avoid wasting time with hardware adaptations that have known issues. Also, your device might have some hardware defects - testing in Android verifies that all components are working correctly, so you have a functionality baseline to compare your Sailfish OS build results with.</p> <p>You should at least check the following features:</p> <ul> <li>OpenGL ES 2.0: Use e.g.   Gears for Android   to test (the hz you will get there will be max refresh rate).</li> <li>WLAN connectivity: Connect to an AP, ad-hoc or set up a mobile access   point with your device.</li> <li>Audio: Headset detection, earpiece speaker, loudspeakers, etc.</li> <li>Bluetooth: Connect to bluetooth headsets, verify discoverability,   send files.</li> <li>NFC: Check if NFC tags can be detected, read and/or written by the device.</li> <li>SD/MicroSD: Use a file manager app to see if inserted SD cards can be   detected.</li> <li>USB: MTP, mass storage (if available) and <code>adb</code> access.</li> <li>Telephony: 2G/3G/LTE calls + data connectivity.</li> <li>GPS: Using   GPS Test,   check GLONASS too; typical time to fix; AGPS.</li> <li>Sensors: Using   AndroSensor:   Accelerometer, Proximity Sensor, Ambient Light Sensor, Gyroscope,    Magnetometer (Compass), Hall (flip case), ...</li> <li>LEDs: If your device has notification LEDs or keypad backlights.</li> <li>Camera (front and back): Also test functionality of zoom, flash, etc..</li> <li>Buttons: Volume up, volume down, power, camera shutter, etc..</li> <li>Video out: HDMI / MHL connectivity if you have the necessary adapters.   TV out.</li> <li>Screen backlight: Suspend and backlight control, minimum and maximum   brightness.</li> <li>Battery meter: Charge level, battery health, charging via USB   (wall charger and host PC).</li> <li>Vibration motor: Intensity, patterns.</li> <li> <p>HW composer version: check <code>dumpsys SurfaceFlinger</code> through ADB (see   SF Layer Debugging).</p> </li> <li> <p>Fingerprint sensor</p> </li> <li>FM Radio</li> </ul> <p>We recommend that you write down the results of these tests, so you can always remember them.</p>"},{"location":"prerequisites/","title":"Prerequisites","text":""},{"location":"prerequisites/#mobile-device","title":"Mobile Device","text":"<ul> <li> <p>An Android device officially supported by LineageOS 15.1 (Android 8),   16.0 (Android 9) and 17.1 (Android 10) at the time of writing 2021-02-12.   CyanogenMod versions (that are Sailfish OS-compatible) 10.1.x, 11.0, 12.1,   13.0, 14.1 will require additional effort because CM has become obsolete.   For more supported Android versions also check this link.</p> <ul> <li> <p>Throughout this guide we shall use the term Android base, which will   refer to the appropriate base that you are porting on: LineageOS, AOSP, CAF etc.</p> </li> <li> <p>We also support Sony Open Devices program, and published guidelines how to   rebuild flashable images for:</p> <ul> <li>Xperia X (Sony AOSP 6)</li> <li>Xperia XA2 (Sony AOSP 8)</li> <li>Xperia 10 (Sony AOSP 9)</li> <li>Xperia 10 II (Sony AOSP 10)</li> <li>Xperia 10 III (Sony AOSP 11)</li> </ul> </li> <li> <p>Starting with Sailfish OS 3.4.0, support for 64bit ARM SFOS userspace has   been added.</p> </li> <li> <p>Sailfish OS adaptations starting with CM 13.0 (Android 6) were   constructed by running a mix of 64bit Linux Kernel and Android HAL, whilst   Sailfish OS userspace was being run in the 32bit mode. Such mixed mode is   still supported, but we encourage porters to switch to full 64bit ports   (using Xperia 10 II as reference)</p> </li> <li> <p>See https://wiki.lineageos.org/devices for a list of compatible devices.</p> </li> <li> <p>See https://wiki.merproject.org/wiki/Adaptations/libhybris for a status   list of devices already ported using HADK.</p> </li> <li> <p>See https://wiki.merproject.org/wiki/Adaptations/libhybris/porters   for a list of ports in early stages, and their authors to contact on the IRC.</p> </li> <li> <p>AOSP or CAF Android base support is also possible, but we choose LineageOS   for a wider range of devices. It will be up to the porter to patch an   AOSP/CAF base with hybris patches. Remaining differences in using it are   minimal (e.g. using the <code>lunch</code> command instead of <code>breakfast</code>).</p> </li> </ul> </li> <li> <p>Means to do backup and restore of the device contents (e.g. SD card or USB   cable to host computer), as well as flash recovery images to the device</p> </li> </ul>"},{"location":"prerequisites/#build-machine","title":"Build Machine","text":"<ul> <li>A 64-bit x86 machine with a 64-bit Linux kernel</li> <li>Sailfish OS Platform SDK (installation explained later)</li> <li>At least 30 GiB of free disk space (20 GiB source download + more for building)   for a complete Android 6 build; a minimal download and HADK build (only   hardware adaptation-related components) requires slightly less space.   Newer Android base versions yield increasingly bigger size requirements.</li> <li>At least 4 GiB of RAM (the more the better)</li> </ul>"},{"location":"repos/","title":"List of Repositories","text":"droid-hal-$DEVICE <p>Contains RPM packaging and conversion scripts for converting the results of the Android HAL build process to RPM packages and systemd configuration files.</p> hybris-boot <p>Script run during Android HAL build that will combine the kernel and a custom initrd to <code>hybris-boot.img</code> and <code>hybris-recovery.img</code>. Those are used to boot a device into Sailfish OS and for development purposes.</p> hybris-installer <p>Combines the <code>hybris-boot</code> output and the root filesystem into a .zip file that can be flashed via Android Recovery.</p> libhybris <p>Library to allow access to Bionic-based libraries from a glibc-based host system (e.g. hwcomposer, EGL, GLESv2, ..).</p> qt5-qpa-hwcomposer-plugin <p>Qt 5 Platform Abstraction Plugin that allows fullscreen rendering to the Droid-based hardware abstraction. It utilizes libhybris and the Android hwcomposer module.</p> mer-kernel-check <p>A script that checks if the kernel configuration is suitable for Sailfish OS. Some features must be enabled, as they are needed on Sailfish OS (e.g. to support <code>systemd</code>), other features must be disabled, as they conflict with Sailfish OS (e.g. <code>CONFIG_ANDROID_PARANOID_NETWORK</code>) at the moment.</p>"},{"location":"setupsdk/","title":"Setting up the SDKs","text":""},{"location":"setupsdk/#setting-up-required-environment-variables","title":"Setting up required environment variables","text":"<p>Throughout this guide we will be referencing the location of your SDK, device build environment and source code. As is customary with Android hardware adaptations, the device vendor (<code>$VENDOR</code>) and device codename (<code>$DEVICE</code>) are also used, both in scripts and configuration files. Throughout this guide as example, we'll use Nexus 5 (lge/hammerhead for its vendor/device pair), and port it using CyanogenMod 11.0 version as the \"Android base\". Thus ensure you read the code snippets carefully and rename where appropriate for your ported device/vendor/base.</p> <p>Now run the following commands on your host operating system fitting for your device and setup:</p> HOST<pre><code>cat &lt;&lt;'EOF' &gt; $HOME/.hadk.env\nexport ANDROID_ROOT=\"$HOME/hadk\"\nexport VENDOR=\"lge\"\nexport DEVICE=\"hammerhead\"\n# \"armv7hl\" is still supported, but we encourage to have full 64bit ports\nexport PORT_ARCH=\"aarch64\"\n# Uncomment the next line to conveniently build all RPMs in local repo:\n#alias mb2='mb2 --output-dir \"${ANDROID_ROOT?}/droid-local-repo/${DEVICE?}\"'\nEOF\n\ncat &lt;&lt;'EOF' &gt;&gt; $HOME/.mersdkubu.profile\nfunction hadk() { source $HOME/.hadk.env; echo \"Env setup for $DEVICE\"; }\nexport PS1=\"HABUILD_SDK [\\${DEVICE}] $PS1\"\nhadk\nEOF\n</code></pre> <p>This ensures that the environment is setup correctly when you use the <code>ubu-chroot</code> command to enter the Android SDK.</p> <p>It also creates a function <code>hadk</code> that you can use to set or reset the environment variables.</p>"},{"location":"setupsdk/#setup-the-platform-sdk","title":"Setup the Platform SDK","text":"<p>Instructions are found on Sailfish OS docs (\"Quick start\" section is enough, do not install SDK Targets yet): https://docs.sailfishos.org/Tools/Platform_SDK/Installation/</p> <p>Afterwards, temporarily leave the <code>PLATFORM SDK</code> to top up your <code>~/.bashrc</code> with necessary commands:</p> PLATFORM SDK<pre><code>exit\n</code></pre> HOST<pre><code>cat &lt;&lt;'EOF' &gt;&gt; $HOME/.bashrc\nif [[ $SAILFISH_SDK ]]; then\n    function hadk() { source $HOME/.hadk.env; echo \"Env setup for $DEVICE\"; }\n    hadk\nfi\nEOF\n\nsfossdk\n</code></pre> <p>Warning</p> <p>With Platform SDK version 4.4.0.58 and olders you need to check the <code>MERSDK</code> variable instead of <code>SAILFISH_SDK</code> in the above code snippet.</p> <p>You'll need some tools which are not installed into the Platform SDK by default:</p> <ul> <li>android-tools-hadk contains tools and utilities needed for working with   the Android SDK</li> <li>kmod is needed by mic's qemu to build the image</li> <li>createrepo_c is needed when passing local repo to mic</li> </ul> PLATFORM SDK<pre><code>sudo zypper ref\nsudo zypper in android-tools-hadk kmod createrepo_c\n</code></pre> <p>The minimum Platform SDK SFOS version is 4.3.0.15. Use <code>sdk-assistant</code> command to upgrade your build tools, or create from new (especially when updating from 2.x to 3.x). To check what release you are on:</p> PLATFORM SDK<pre><code># if no such file, you're on an old SDK version\ncat /etc/os-release\n</code></pre> <p>More information about keeping your SDK up-to-date: https://github.com/sailfishos/sdk-setup/blob/master/sdk-setup/README.tips.wiki#SDK_Maintenance</p>"},{"location":"setupsdk/#setting-up-an-android-build-environment","title":"Setting up an Android Build Environment","text":""},{"location":"setupsdk/#downloading-and-unpacking-ubuntu-chroot","title":"Downloading and Unpacking Ubuntu Chroot","text":"<p>In order to maintain build stability, we use a Ubuntu GNU/Linux <code>chroot</code> environment from within the Platform SDK to build our Android source tree. For Android device ports that require OpenJDK 1.8 or newer, the following commands download and unpack the rootfs to the appropriate location:</p> PLATFORM SDK<pre><code>TARBALL=ubuntu-focal-20210531-android-rootfs.tar.bz2\ncurl -O https://releases.sailfishos.org/ubu/$TARBALL\nUBUNTU_CHROOT=$PLATFORM_SDK_ROOT/sdks/ubuntu\nsudo mkdir -p $UBUNTU_CHROOT\nsudo tar --numeric-owner -xjf $TARBALL -C $UBUNTU_CHROOT\n</code></pre> <p>In case you find you're not able to gain <code>sudo</code> privileges inside the Ubuntu Chroot, execute the following inside the Platform SDK:</p> PLATFORM SDK<pre><code>sudo chroot $UBUNTU_CHROOT /bin/bash -c \"chage -M 999999 $(id -nu 1000)\"\n</code></pre>"},{"location":"setupsdk/#entering-ubuntu-chroot","title":"Entering Ubuntu Chroot","text":"PLATFORM SDK<pre><code>ubu-chroot -r $PLATFORM_SDK_ROOT/sdks/ubuntu\n</code></pre> <p>Note</p> <p>FIXME: Hostname resolution might fail. This error can be ignored. Can be fixed manually by adding the hostname to /etc/hosts</p> <p>Now you are in the <code>HABUILD SDK</code> environment. To leave, just type <code>exit</code> or Ctrl+D, and you'll be back to the <code>PLATFORM SDK</code>.</p>"},{"location":"setupsdk/#if-your-port-requires-openjdk-17-or-older","title":"If your port requires OpenJDK 1.7 or older","text":"<p>Our ubu-chroot environment is based on 20.04 LTS which provides OpenJDK 1.8 or newer.</p> <p>If your Android base build requires an older Java Development Kit, please install the legacy ubu-chroot instead:</p> PLATFORM SDK<pre><code>TARBALL=ubuntu-trusty-20180613-android-rootfs.tar.bz2\ncurl -O https://releases.sailfishos.org/ubu/$TARBALL\nUBUNTU_CHROOT=$PLATFORM_SDK_ROOT/sdks/ubuntu\nsudo mkdir -p $UBUNTU_CHROOT\nsudo tar --numeric-owner -xjf $TARBALL -C $UBUNTU_CHROOT\n</code></pre>"},{"location":"subsystems/","title":"Detailed subsystem adaptation guides","text":"<p>Sailfish OS uses some kernel interfaces directly, bypassing the android HAL. Mainly this is used in places where the kernel API is stable enough and also used by Android. The other reasons for using kernel APIs directly include better features offered by standard kernel frameworks, differing middleware between Sailfish OS linux and Android, and lastly special features of Sailfish OS.</p>"},{"location":"subsystems/#vibration-force-feedback","title":"Vibration / force feedback","text":"<p>The default vibra framework that is used in full featured productized Sailfish OS devices is the force feedback API in kernel input framework. The kernel drivers should either use the ffmemless framework OR provide FF_PERIODIC and FF_RUMBLE support via as a normal input driver. In this chapter we go through the ff-memless aproach of adapting your kernel for Sailfish OS</p> <p>This is a different method than what is used in community Sailfish OS ports, which utilize the android vibrator / timed-output API. The android vibrator plugins in Sailfish OS middleware have very reduced feature set, and are not recommended for commercial products.</p> <p>In order to utilize the standard input framework force feedback features of Sailfish OS, the android timed output vibrator kernel driver needs to be converted to a ffmemless driver. The main tasks for this are:</p> <ul> <li>Enable CONFIG_INPUT_FF_MEMLESS kernel config option</li> <li>Disable CONFIG_ANDROID_TIMED_OUTPUT kernel config option</li> <li>Change maximum amount of ffmemless effects to 64 by patching   ff-memless.c:<ul> <li>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/drivers/input/ff-memless.c#n41</li> </ul> </li> </ul> <pre><code>diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c\nindex 117a59a..fa53611 100644\n--- a/drivers/input/ff-memless.c\n+++ b/drivers/input/ff-memless.c\n@@ -39,7 +39,7 @@ MODULE_AUTHOR(\"Anssi Hannula &lt;anssi.hannula@gmail.com&gt;\");\n MODULE_DESCRIPTION(\"Force feedback support for memoryless devices\");\n\n /* Number of effects handled with memoryless devices */\n-#define FF_MEMLESS_EFFECTS     16\n+#define FF_MEMLESS_EFFECTS     64\n\n /* Envelope update interval in ms */\n #define FF_ENVELOPE_INTERVAL   50\n</code></pre> <ul> <li>Optionally you can decrease ff-memless control interval so that fade   and attack envelopes can be used in short haptic effects as well:</li> </ul> <pre><code>diff --git a/drivers/input/ff-memless.c b/drivers/input/ff-memless.c\nindex 89d3a3d..33eee2e 100644\n--- a/drivers/input/ff-memless.c\n+++ b/drivers/input/ff-memless.c\n@@ -41,7 +41,7 @@ MODULE_DESCRIPTION(\"Force feedback support for memoryless devi\n #define FF_MEMLESS_EFFECTS     64\n\n /* Envelope update interval in ms */\n-static int ff_envelope_interval = 50;\n+static int ff_envelope_interval = 10;\n module_param(ff_envelope_interval, int, S_IWUSR | S_IRUGO);\n\n #define FF_EFFECT_STARTED      0\n</code></pre> <ul> <li>If your platform happens to already support a ffmemless based vibra   driver, just enable it and fix any issues that you see. Otherwise go   through the rest of the points below.</li> <li>Convert the android timed output vibra driver to support to   ffmemless<ul> <li>add <code>#include &lt;linux/input.h&gt;</code></li> <li>Create a ffmemless play function.</li> <li>Examples of ffmemless play functions / ffmemless drivers:<ul> <li>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/drivers/input/misc/arizona-haptics.c#n110</li> <li>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/drivers/input/misc/max8997_haptic.c#n231</li> <li>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/drivers/input/misc/pm8xxx-vibrator.c#n130</li> </ul> </li> <li>At probe, create a ffmemless device with input_ff_create_memless<ul> <li>http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/input.h#n531</li> </ul> </li> <li>And register the resulting device with input_device_register.</li> <li>Remember to clean up the input device structure at driver exit</li> <li>The example ffmemless drivers above can be used for reference</li> </ul> </li> </ul> <p>The userspace configuration haptic feedback and effects is handled with ngfd configuration files, see more details in Middleware / NGFD</p>"},{"location":"subsystems/#gstreamer-v10","title":"GStreamer v1.0","text":"<p>Sailfish OS 2.0 introduces GStreamer v1.0 with hardware-accelerated video and audio encoding and decoding in Camera, Gallery and Browser, and deprecates GStreamer v0.10.</p> <p>The GStreamer-droid bridge is part of the integral build process. If you need to modify its source code, then rebuild it via:</p> PLATFORM SDK<pre><code>cd $ANDROID_ROOT\nrpm/dhd/helpers/build_packages.sh --gg\n</code></pre>"},{"location":"subsystems/#camera","title":"Camera","text":"<p>Launch the Camera app. If if shows black screen and becomes non-responsive, enable the <code>audiosystem-passthrough-dummy-af</code> package in the patterns and rebuild droid-configs.</p> <p>If you find some parameters (such as ISO speed or other 3A settings) are missing from camera app, then it's possible that your camera device is designed to use an older version of the Camera HAL than the default. You can try forcing a HAL v1 connection by adding <code>FORCE_HAL:=1</code> to <code>env.mk</code> in droidmedia.</p>"},{"location":"subsystems/#cellular-modem","title":"Cellular modem","text":"<ul> <li> <p>Ensure Android's RIL running <code>ps ax | grep rild</code> (expect one or two   <code>/system/bin/rild</code>)</p> </li> <li> <p>If RIL is not running, check why it is not launched from <code>/init*.rc</code>   scripts</p> </li> <li> <p>If it's launched, check where it fails with   <code>/usr/libexec/droid-hybris/system/bin/logcat -b radio</code></p> </li> <li> <p>Errors in RIL might look like this:   <pre><code>RIL[0][main] qcril_qmi_modem_power_process_bootup: ESOC node is not available\n</code></pre>   After online search this suggests firmware loading issues on   Motorola Moto G. Compare with a healthy radio logcat after booting   back into CM, not all lines starting with <code>E/RIL...</code> will point to a   root cause!</p> </li> <li> <p>If it's firmware loading problem, trace all needed daemons in CM   and their loading order as well as all mounted firmware, modem, and   baseband partitions.</p> </li> <li> <p>Once RIL is happy, then ofono can be launched. Unmask it if it was   previously masked due to causing reboots in   bootloops.</p> </li> <li> <p>If you still get no signal indicator in UI, remove SIM PIN and retry</p> </li> <li> <p>Also install <code>ofono-tests</code> package and run <code>/usr/lib/ofono/test/list-modems</code></p> </li> <li> <p>Try to recompile latest ofono master branch from   https://github.com/sailfishos/ofono</p> </li> <li> <p>If everything else fails, then stop and strace a failing daemon   (either RIL or ofono) from command line manually</p> </li> </ul>"},{"location":"subsystems/#phone-calls-dont-work-but-sms-and-mobile-data-works","title":"Phone calls don't work (but SMS and mobile data works)","text":"<p>If the calling parties cannot hear one another, then the <code>audiosystem-passthrough-dummy-af</code> middleware package is required, which should be enabled in the patterns.</p>"},{"location":"subsystems/#bluetooth","title":"Bluetooth","text":"<p>For bluetooth Sailfish OS uses BlueZ stack from linux.</p> <p>Todo</p> <ul> <li>bluetooth adaptation guide.</li> <li>add detail about audio routing.</li> </ul>"},{"location":"subsystems/#wlan","title":"WLAN","text":"<p>Typically WLAN drivers are external kernel modules in android adaptations. To set up WLAN for such devices, a systemd service file needs to be created that loads the kernel module at boot. In addition to this you need to check that firmware files and possible HW tuning files are installed in correct locations on the filesystem.</p> <p>Sailfish OS WLAN adaptation assumes the driver is compatible with WPA supplicant. This means the WLAN device driver has to support cfg80211 interface. In some cases connman (the higher level connection manager in Sailfish) accesses directly the WLAN driver bypassing wpa_supplicant.</p> <p>The version of currently used wpa_supplicant can be checked from here:</p> <ul> <li>https://github.com/sailfishos/wpa_supplicant</li> </ul> <p>The version of used connman can be checked from here:</p> <ul> <li>https://github.com/sailfishos/connman</li> </ul>"},{"location":"subsystems/#special-quirks-wlan-hotspot","title":"Special quirks: WLAN hotspot","text":"<p>On some android WLAN drivers, the whole connectivity stack needs to be reset after WLAN hotspot use. For that purpose there is reset service in dsme, please see details how to set that up for your adaptation project in here:</p> <ul> <li>https://github.com/sailfishos/dsme/commit/c377c349079b470db38ba6394121b6d899004963</li> </ul>"},{"location":"subsystems/#nfc","title":"NFC","text":"<p>Currently there is no NFC middleware in Sailfish OS. Android HAL API support should be enough for future compatibility.</p>"},{"location":"subsystems/#gps","title":"GPS","text":"<p>Ensure the <code>test_gps</code> command gets a fix after a while.</p> <p>The necessary middleware is already built for you, just add <code>geoclue-provider-hybris</code> package into your patterns.</p>"},{"location":"subsystems/#audio","title":"Audio","text":"<p>For audio, Sailfish OS uses PulseAudio as the main mixer. For audio routing ohmd is used.</p> <p>Todo</p> <p>Add info about audio routing configuration TODO: Add more info in general.</p>"},{"location":"subsystems/#sensors","title":"Sensors","text":"<p>Sailfish OS sensor support is based upon Sensor Framework at: https://github.com/sailfishos/sensorfw</p> <p>Hybris based systems can use the hybris sensor adaptor plugins, which uses existing android libhardware sensor adaptations to read sensor data and control.</p> <p>It can also be configured for standard linux sysfs and evdev sensor interfaces.</p> <p>It should be configured at <code>/etc/sensorfw/primaryuse.conf</code>, which links to a device specific conf file. Historically named <code>sensord-&lt;BOARDNAME&gt;.conf</code>. You can also use any conf file by specifying it on the commandline.</p> <p>For hybris based platforms, this will be <code>sensord-hybris.conf</code>, and most likely will not have to be modified. A copy of this file is already among default configs: https://github.com/sailfishos/sensorfw/blob/master/config/sensord-hybris.conf If you do make modifications to it, add the file under <code>$ANDROID_ROOT/hybris/droid-configs/sparse/etc/sensorfw/primaryuse.conf</code></p> <p>There are already a few device specific conf files to look at if the device needs more configuration. Example of mixed hybris and evdev configuration https://github.com/sailfishos/sensorfw/blob/master/config/sensord-tbj.conf</p> <p>Generally, if sensors are working on the android/hybris side, they will work in sensorfw and up to the Sailfish UI. libhybris comes with /usr/bin/test_sensors which can list those Android sensors found.</p> <p>Above Sensor Framework is QtSensors, which requires a configuration file at /etc/xdg/QtProject/Sensors.conf which is supplied with the sensorfw backend plugin in QtSensors and a copy of it is already among your default configs.</p> <p>For Sailfish Core based systems, the QtSensors source code is at: https://github.com/mer-qt/qtsensors</p> <p>Debugging output of sensorfwd can be increased one level during runtime by sending (as root) USR1 signal like so: <code>pkill -USR1 sensorfwd</code> or specified on the commandline for startup debugging.</p> <p>Sending <code>pkill -USR2 sensorfwd</code> will output a current status report.</p>"},{"location":"subsystems/#power-management","title":"Power management","text":"<p>Under the hood, Sailfish OS uses the android wake locks. Typically there is no need to change anything in the kernel side (assuming it works fine with android) for the power management to work, as long as all the device drivers are working normally.</p> <p>The userspace API's for platform applications is exposed via nemo-keepalive package. See more details here:</p> <ul> <li>https://github.com/sailfishos/nemo-keepalive</li> </ul>"},{"location":"subsystems/#watchdog","title":"Watchdog","text":"<p>A standard linux kernel watchdog core driver support is expected. The device node should be in /dev/watchdog. It should be configured with following kernel options:</p> <pre><code>CONFIG_WATCHDOG=y\nCONFIG_WATCHDOG_CORE=y\nCONFIG_WATCHDOG_NOWAYOUT=y\n</code></pre> <p>Note</p> <p>Please note that watchdog driver should disable itself during suspend.</p> <p>Note</p> <p>Normally the watchdog period is programmed automatically, but if your driver does not support programming the period, the default kicking period is 20 seconds.</p>"},{"location":"subsystems/#touch","title":"Touch","text":"<p>Sailfish OS is compatible with standard kernel multitouch input framework drivers. Protocol A is preferred. The main configuration needed is to symlink the correct event device node to /dev/touchscreen. To do this the best way is to set up a udev rule that checks the devices with evcap script and creates the link once first valid one is found. See more details for evcap here:</p> <ul> <li>https://github.com/mer-hybris/evcap</li> </ul> <p>The udev rule can be put to file <code>/lib/udev/rules.d/61-touchscreen.rules</code></p> <p>The reason this is not done by default is that typically driver authors mark bit varying capabilities as supported and there could be multiple touch controllers on a device, so the final rule is best to be written in a device specific configs package.</p> <p>Note</p> <p>if you still have problems with touch, please check that lipstick environment has correct touch device parameter: <pre><code>cat /var/lib/environment/compositor/droid-hal-device.conf\n</code></pre> LIPSTICK_OPTIONS should have \"-plugin evdevtouch:/dev/touchscreen\"</p>"},{"location":"subsystems/#special-feature-double-tap-to-wake-up","title":"Special feature: double tap to wake up","text":"<p>Sailfish OS supports waking up the device from suspend (unblanking the screen) via double tap gesture to the touchscreen. The touchscreen driver should either emulate KEY_POWER press / release or post a EV_MSC/MSC_GESTURE event with value 0x4 when double tap gesture is detected when waking up from suspend.</p> <p>In order to avoid excess power drain when device is in pocket facing users skin, some sysfs should be exported to allow disabling the touch screen. The feature requires that the device has a working proximity sensor that can wake up the system when it is suspended (to be able to update touch screen state according to need). To configure MCE that handles this see MCE configuration</p>"}]}